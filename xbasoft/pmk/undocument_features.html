<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0">
<title>Недокументированные возможности программируемого микрокалькулятора МК-61</title>
<style>

.but {
	background-color:#CCCCCC;
	color:black;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 12px 0px 12px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_f {
	background-color:#F5E345;
	color:black;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 12px 0px 12px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_k {
	background-color:LightSkyBlue;
	color:white;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 12px 0px 12px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_cx {
	background-color:#F00505;
	color:white;

	font-weight:bold;
	font-family:monospace;

	padding: 1px 8px 1px 8px;

	border:thin solid black;
	border-radius:3px;

	width:12px;
	white-space: nowrap;
}

.but_b {
	background-color:black;
	color:white;

	font-weight:bold;
	font-family:monospace;

	padding:1px 8px 0px 8px;

	border:thin solid Gray;
	border-radius:3px;
	width:12px;
	white-space: nowrap;
}

.code  {
	background-color:#103810;
	color:#77FF77;

	font-family: monospace;
	font-weight:bold;
	padding:1px 2px 1px 2px;
	white-space: nowrap;
}

.reg {
	color:white;
	background-color:black;
	font-weight:bold;
}

.op_f {
	color:yellow;
	background-color:black;
}

.op_k {
	color:blue;
	background-color:#EEEEEE;
}

table {
	border-collapse: collapse;
}

table, th, td {
	border: 1px solid black;
}

.trcenter td, th {
	text-align: center;
}

.tdcenter {
	text-align: center;
}

.trblack td {
	background: #EEEEEE;
}

.trblack_black td {
	background: #BBBBBB;
}

.wall_color {
	background-color: #BBBBBB;
}

.align_right {
	text-align: right;
}

.li_change {
	list-style-type: none;
	text-indent: -1em;
}
.li_change::before {
	content: "*"
}

.li_add {
	list-style-type: none;
	text-indent: -1em;
}
.li_add::before {
	content: "+"
}

h2, h3, h4 {
    display: inline-block;
}

dt {
	margin-top: 1em;
}

.code_num {
	font-weight:bold;
	font-size:small;
}

</style>
</head>

<body>
	<h2>Недокументированные возможности программируемого микрокалькулятора МК-61</h2>

	<details open>
		<summary><h3>Оглавление</h3></summary>
	<nav>
		<ul>
			<li><a href="#div_preface">Предисловие</a></li>
			<li>
				<a href="#div_addr_space">Программное адресное пространство</a>
				<ul><li><a href="#div_addr_space_using">Практическое применение</a></li></ul>
			</li>
			<li>
				<a href="#div_indirect_addr">Косвенная адресация</a>
				<ul>
					<li><a href="#div_indirect_addr_gt1">
						Число больше или равно единицы
					</a></li>
					<li><a href="#div_indirect_addr_lt1">
						Число положительное, но меньше единицы
					</a></li>
					<li><a href="#div_indirect_addr_negative">
						Число отрицательное
					</a></li>
					<li><a href="#div_indirect_addr_R0">
						Регистры R0&hellip;R3
					</a></li>
					<li><a href="#div_indirect_addr_R4">
						Регистры R4&hellip;R6
					</a></li>
					<li><a href="#div_indirect_addr_FL0">
						Команды
						<span class="but_f">F</span><span class="op_f">FL0</span>&hellip;
						<span class="but_f">F</span><span class="op_f">FL3</span>
					</a></li>
					<li><a href="#div_indirect_addr_mantissa">
						Мантисса содержит шестнадцатеричные цифры
					</a></li>
					<li><a href="#div_indirect_addr_exponent">
						Порядок содержит шестнадцатеричные цифры
					</a></li>
					<li><a href="#div_indirect_addr_reg">
						Значение &ndash; номер регистра, а не адрес
					</a></li>
					<li><a href="#div_indirect_addr_using">
						Практическое использование
					</a></li>
				</ul>
			</li>
			<li>
				<a href="#div_x2">Таинственный регистр X2</a>
				<ul>
					<li><a href="#div_x2_affect">
						X2-влияющие команды
					</a></li>
					<li><a href="#div_x2_point">
						Команда <span class="but">.</span> (код 0A)
					</a></li>
					<li>
						<a href="#div_x2_exp">Команда <span class="but">ВП</span> (код 0C)</a>
						<ul>
							<li><a href="#div_x2_exp_SR">
								Восстановление X2 с отбрасыванием первой цифры
							</a></li>
							<li><a href="#div_x2_exp_combine">
								Восстановление X2 с заменой первой цифры на цифру из числа в X
							</a></li>
							<li><a href="#div_x2_exp_goto">
								<span class="but">ВП</span> сразу после косвенного перехода
							</a></li>
							<li><a href="#div_x2_exp_plus">
								Использование <span class="but">ВП</span> как сложение
							</a></li>
							<li><a href="#div_x2_exp_down">
								Команда <span class="but">.</span> перед
								<span class="but">ВП</span> "сдвигает" захват X
							</a></li>
						</ul>
					</li>
					<li><a href="#div_x2_sum">Итог</a></li>
				</ul>
			</li>
			<li>
				<a href="#div_hex">Шестнадцатеричная арифметика</a>
				<ul>
					<li><a href="#div_hex_h_plus_y">
						Операция H <span class="but">+</span> Y (сложение)
					</a></li>
					<li><a href="#div_hex_x_plus_h">
						Операция X <span class="but">+</span> H (сложение)
					</a></li>
					<li><a href="#div_hex_y_minus_h">
						Операция Y <span class="but">-</span> H (вычитание)
					</a></li>
					<li><a href="#div_hex_h_minus_x">
						Операция H <span class="but">-</span> X (вычитание)
					</a></li>
					<li><a href="#div_hex_h_mult_y">
						Операция H <span class="but">&times;</span> Y (умножение)
					</a></li>
					<li><a href="#div_hex_x_mult_h">
						Операция X <span class="but">&times;</span> H (умножение)
					</a></li>
					<li><a href="#div_hex_h_div_x">
						Операция H <span class="but">&divide;</span> X (деление)
					</a></li>
					<li><a href="#div_hex_y_div_h">
						Операция Y <span class="but">&divide;</span> H (деление)
					</a></li>
					<li><a href="#div_hex_func">
						Результат функций над шестнадцатеричными числами
					</a></li>
					<li><a href="#div_hex_using">
						Практическое применение
					</a></li>
				</ul>
			</li>
			<li>
				<a href="#div_zero_digit">Числа, у которых вместо знака стоит цифра</a>
				<ul>
					<li><a href="#div_zero_digit_get">Способы получения
					</a></li>
					<li><a href="#div_zero_digit_sign">Какой знак у числа?
					</a></li>
					<li><a href="#div_zero_digit_eval">Арифметика с этими числами
					</a></li>
					<li><a href="#div_zero_digit_sum">Произвольная мантисса и выводы
					</a></li>
				</ul>
			</li>
			<li>
				<a href="#div_neg_zero_degree">Числа с отрицательной нулевой степенью</a>
				<ul>
					<li><a href="#div_nzd_get">Способ получения
					</a></li>
					<li><a href="#div_nzd_plus">Сложение и вычитание
					</a></li>
					<li><a href="#div_nzd_mult">Умножение и деление
					</a></li>
					<li><a href="#div_nzd_func_F">"Жёлтые" функции
					</a></li>
					<li><a href="#div_nzd_func_K">"Синие" функции
					</a></li>
					<li><a href="#div_nzd_sum">Итог
					</a></li>
				</ul>
			</li>
			<li><a href="#div_tricks">Трюки по оптимизации</a></li>
			<li>
				<a href="#div_demo">Демонстрационная программа</a>
				<ul>
					<li><a href="#div_demo_preface">Описание интерфейса программы
					</a></li>
				</ul>
				<ul>
					<li><a href="#div_demo_detail">Разбор программы
					</a></li>
				</ul>
				<ul>
					<li><a href="#div_demo_full">Полный текст программы
					</a></li>
				</ul>
				<ul>
					<li><a href="#div_demo_tricks">
						Список трюков и недокументированных	особенностей в программе
					</a></li>
				</ul>
			</li>
			<li><a href="#div_command">Приложение. Все команды</a></li>
			<li><a href="#div_glossary">Список терминов</a></li>
		</ul>
	</nav>
	</details>

	<hr>

	<details id="div_preface" open>
		<summary><h3>Предисловие</h3></summary>
		Предполагается, что читатель знаком с работой на программируемом
		микрокалькуляторе МК-61 (далее просто <a href="#div_glos_calculator">ПМК</a>),
		т.е. с <em>документированными</em> возможностями (см.
		<a href="https://www.wass.net/manuals/Elektronika%20MK-61.pdf" target="_blank">
			руководство по эксплуатации</a>).
		<p>
			<strong>Целью</strong> использования недокументированных возможностей чаще всего
			является сокращение длины программы (самый "узкий" ресурс),
			реже &ndash; высвобождение дополнительных регистров памяти.
			<br>
			Большинство таких возможностей реализуется или используется только в
			контексте программного режима.
			<br>
			Иногда такие возможности используются для получения видео изображения,
			которое невозможно создать обычным способом.
			<br>
			Также знание недокументированных возможностей поможет понять, почему
			иногда программа ведёт себя не совсем так, или совсем не так, как ожидалось.
		</p>
		<p>
			В данной документе не рассматривается получение и исследование
			<a href="#div_glos_super_num">сверхчисел</a> и
			<a href="#div_glos_F">пустышек</a>, которые исторически
			уже рассмотрены <a href="#div_glos_errors">Еггогологией</a>.
			Но из указанной Еггогологии взяты термины
			<a href="#div_glos_err100">ЕГГ0Га</a> и
			<a href="#div_glos_err200">3Г0ГГа</a>, и кое-где
			используются для получения нестандартных чисел или результатов.
		</p>
		<p>
			Далее для обозначения старших шестнадцатеричных цифр используется
			стандартное обозначение <strong>ABCDEF</strong>, при этом в примерах
			отображения используются вид цифр ПМК.
			<br>
			Например, число <strong>8.FEDCBA9</strong> (как инверсия числа 8.0123456),
			будет выглядеть как
			<span class="code">&nbsp;8.&nbsp;EГCL-9&nbsp;&nbsp;&nbsp;</span>.
			<br>
			Следует понимать, что в ПМК шестнадцатеричные только цифры, но не числа,
			то есть ПМК по-прежнему считает каждый разряд как десятичный.
			Т.е. число FF, которое в обычном случае равно 255,
			будет интерпретироваться как F &times; 10 + F, т.е. 150 + 15 = 165.
		</p>
		<p>
			Дробные числа или числа с большим порядком обычно записываются в научной
			нотации как &plusmn;m.mmmmmmmE&plusmn;pp. Чтобы не путать знак экспоненты
			с шестнадцатеричной цифрой E далее такие числа
			будем указывать в форме &plusmn;m.mmmmmmm<strong>^</strong>&plusmn;pp
			(^ вместо E),
			причем знак порядка будем указывать всегда, а для надежности и точку
			(десятичный разделить) для мантиссы. Например, 1.23^-02 будет выглядеть как
			<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>.
		</p>
		<p>
			Т.к. ПМК может использовать
			<a href="#div_glos_unnormalize">не нормализованные числа</a>, то это важно
			отличать, пример: не нормализованное 0.005^-03 это
			<span class="code">&nbsp;0.005&nbsp;&nbsp;&nbsp;&nbsp;-03</span>,
			а оно же нормализованное &ndash; это 5.^-06
			<span class="code">&nbsp;5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-06</span>.
			Не нормализованные числа в тексте так и будут записываться с ведущими нулями.
		</p>
	</details>

	<hr>

	<details id="div_addr_space" open>
		<summary><h3>Программное адресное пространство</h3></summary>
		Документированное значение для адресов программы &ndash; 105 ячеек.
		Фактически всё немного сложнее.
		Напомним, что адресация ячеек использует только две цифры, поэтому для
		адресов более 99 используются шестнадцатеричные цифры.
		<p></p>
		<table class="trcenter">
			<tr><th>Адрес формальный</th><th>Адрес фактический</th><th>Доп. адрес</th></tr>
			<tr><td>00</td><td>00</td><td></td></tr>
			<tr><td>01</td><td>01</td><td></td></tr>
			<tr><td colspan=3>&hellip;</tr>
			<tr><td>99</td><td>99</td><td></td></tr>
			<tr><td>A0</td><td>A0</td><td></td></tr>
			<tr><td>A1</td><td>A1</td><td></td></tr>
			<tr><td>A2</td><td>A2</td><td></td></tr>
			<tr><td>A3</td><td>A3</td><td></td></tr>
			<tr><td>A4</td><td>A4</td><td></td></tr>
			<tr><td colspan=3></td></tr>
			<tr><td>A5</td><td>00</td><td></td></tr>
			<tr><td>A6</td><td>01</td><td></td></tr>
			<tr><td>A7</td><td>02</td><td></td></tr>
			<tr><td>A8</td><td>03</td><td></td></tr>
			<tr><td>A9</td><td>04</td><td></td></tr>
			<tr><td>B0</td><td>05</td><td></td></tr>
			<tr><td>B1</td><td>06</td><td></td></tr>
			<tr><td colspan=3></td></tr>
			<tr><td>B2</td><td>00</td><td></td></tr>
			<tr><td>B3</td><td>01</td><td></td></tr>
			<tr><td>B4</td><td>02</td><td></td></tr>
			<tr><td>B5</td><td>03</td><td></td></tr>
			<tr><td>B6</td><td>04</td><td></td></tr>
			<tr><td>B7</td><td>05</td><td></td></tr>
			<tr><td>B8</td><td>06</td><td></td></tr>
			<tr><td>B9</td><td>07</td><td></td></tr>
			<tr class="trblack"><td>C0</td><td>08</td><td></td></tr>
			<tr class="trblack"><td>C1</td><td>09</td><td></td></tr>
			<tr class="trblack"><td>C2</td><td>10</td><td></td></tr>
			<tr class="trblack"><td>C3</td><td>11</td><td></td></tr>
			<tr class="trblack"><td>C4</td><td>12</td><td></td></tr>
			<tr class="trblack"><td>C5</td><td>13</td><td></td></tr>
			<tr class="trblack"><td>C6</td><td>14</td><td></td></tr>
			<tr class="trblack"><td>C7</td><td>15</td><td></td></tr>
			<tr class="trblack"><td>C8</td><td>16</td><td></td></tr>
			<tr class="trblack"><td>C9</td><td>17</td><td></td></tr>
			<tr class="trblack"><td>D0</td><td>18</td><td></td></tr>
			<tr class="trblack"><td>D1</td><td>19</td><td></td></tr>
			<tr class="trblack"><td>D2</td><td>20</td><td></td></tr>
			<tr class="trblack"><td>D3</td><td>21</td><td></td></tr>
			<tr class="trblack"><td>D4</td><td>22</td><td></td></tr>
			<tr class="trblack"><td>D5</td><td>23</td><td></td></tr>
			<tr class="trblack"><td>D6</td><td>24</td><td></td></tr>
			<tr class="trblack"><td>D7</td><td>25</td><td></td></tr>
			<tr class="trblack"><td>D8</td><td>26</td><td></td></tr>
			<tr class="trblack"><td>D9</td><td>27</td><td></td></tr>
			<tr class="trblack"><td>E0</td><td>28</td><td></td></tr>
			<tr class="trblack"><td>E1</td><td>29</td><td></td></tr>
			<tr class="trblack"><td>E2</td><td>30</td><td></td></tr>
			<tr class="trblack"><td>E3</td><td>31</td><td></td></tr>
			<tr class="trblack"><td>E4</td><td>32</td><td></td></tr>
			<tr class="trblack"><td>E5</td><td>33</td><td></td></tr>
			<tr class="trblack"><td>E6</td><td>34</td><td></td></tr>
			<tr class="trblack"><td>E7</td><td>35</td><td></td></tr>
			<tr class="trblack"><td>E8</td><td>36</td><td></td></tr>
			<tr class="trblack"><td>E9</td><td>37</td><td></td></tr>
			<tr class="trblack"><td>F0</td><td>38</td><td></td></tr>
			<tr class="trblack"><td>F1</td><td>39</td><td></td></tr>
			<tr class="trblack"><td>F2</td><td>40</td><td></td></tr>
			<tr class="trblack"><td>F3</td><td>41</td><td></td></tr>
			<tr class="trblack"><td>F4</td><td>42</td><td></td></tr>
			<tr class="trblack"><td>F5</td><td>43</td><td></td></tr>
			<tr class="trblack"><td>F6</td><td>44</td><td></td></tr>
			<tr class="trblack"><td>F7</td><td>45</td><td></td></tr>
			<tr class="trblack"><td>F8</td><td>46</td><td></td></tr>
			<tr class="trblack"><td>F9</td><td>47</td><td></td></tr>
			<tr><td colspan=3></td></tr>
			<tr class="trblack_black"><td>FA</td><td>48</td><td>01</td></tr>
			<tr class="trblack_black"><td>FB</td><td>49</td><td>02</td></tr>
			<tr class="trblack_black"><td>FC</td><td>50</td><td>03</td></tr>
			<tr class="trblack_black"><td>FD</td><td>51</td><td>04</td></tr>
			<tr class="trblack_black"><td>FE</td><td>52</td><td>05</td></tr>
			<tr class="trblack_black"><td>FF</td><td>53</td><td>06</td></tr>
		</table>
		<p>
			Первая побочная ветвь (возврат на нулевой адрес) короткая &ndash;
			адреса A5&hellip;B1, которые отображаются на адреса 00&hellip;06.
		</p>
		<p>
			Вторая побочная ветвь длинней &ndash; адреса B2&hellip;F9, которые
			отображаются на адреса 00&hellip;37.
			Причем адреса C0&hellip;F9 являются <a href="#div_glos_shadow">темными</a>,
			Например, если выполнить
			<span class="but_b">БП</span>&ensp;
			<span class="but">10</span>&ensp;
			<span class="but_f">F</span><span class="op_f">ПРГ</span>, и
			по адресам 10&hellip;12 ввести команды
			<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
			<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
			<span class="but_k">К</span><span class="op_k">НОП</span>,
			то мы увидим
			<span class="code">&nbsp;54&nbsp;54&nbsp;54&nbsp;13</span>.
			Но если затем перейти на адрес C5
			(<span class="but_f">F</span><span class="op_f">АВТ</span>&ensp;
			<span class="but_b">БП</span>&ensp;
			<span class="but">C5</span>&ensp;
			<span class="but_f">F</span><span class="op_f">ПРГ</span>), то получим
			<span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C5</span>,
			хотя фактически этот будет тот же программный код.
		</p>
		<p>
			На <strong>супертемные</strong> адреса FA&hellip;FF можно перейти
			только косвенно,
			т.к. впрямую адрес, начинающийся с цифры F не вбить.
			Впрочем, некоторые нестандартные последовательности команд в ручном
			режиме, описанные в конце <a href="#div_command">приложения</a>,
			позволяют вставлять команды,
			начинающиеся с F. А также для владельцев МК-52 есть штатный способ
			сделать "or" команд с отдельного модуля, с получением кодов с цифрой F.
			<br>
			Так вот, особенность супертемных адресов такая, что после перехода на
			него выполняется только одна(!) команда, а затем идёт переход на
			дополнительный адрес, который указан в последней колонке.
		</p>
		<p>
			Если в адресе перехода вторая цифра тоже шестнадцатеричная, то как
			указано в предисловии, она прибавляется как есть (E = 14 и т.п.).
			Таким образом переход на адреса 9F (90 + 15) или A5 (100 + 5) или
			AC (100 + 12 = 110 + 2 = B2) или B2, будет
			эквивалентно переходу на адрес 00, только потом порядок команд
			будет отличаться.
		</p>
		<p>
			Если сама команда двойная, т.е. с адресом перехода (например,
			<span class="but_b">БП</span>,
			<span class="but_f">F</span><span class="op_f">x&lt;0</span>,
			<span class="but_f">F</span><span class="op_f">L1</span>),
			и при этом идёт "разрыв" адресации, то вторая часть команды
			(адрес перехода) считывается из нового места. Т.е. если по адресу 06
			стоит команда <span class="but_b">БП</span>,
			то в обычном потоке адрес перехода будет по адресу 07, но если
			попали сюда как на адрес B1, то адрес перехода будет по адресу 00.
		</p>

		<details id="div_addr_space_using" open>
			<summary><h4>Практическое применение</h4></summary>
			<ul>
				<li>
					Расположения управляющих потоком выполнения команд по начальным
					адресам, а в конце программы (или в середине, в зависимости от
					побочной ветви) их не использовать (автоматический переход на начало
					основной ветви)
					для сокращения длины программы.  Чаще всего в этом качестве выступает
					<span class="but_b">В/О</span>, но можно и условные переходы,
					<span class="but_b">С/П</span> и др.
				</li>
				<li>
					Использование разных значений для фактического перехода по одному и
					тому же адресу (указано выше). Нестандартное ветвление.
				</li>
				<li>
					Изменение адреса перехода сдвоенной команды, в зависимости от
					формального адреса (указано выше). Также нестандартное ветвление.
				</li>
			</ul>
		</details>

	</details>

	<hr>

	<details id="div_indirect_addr" open>
		<summary><h3>Косвенная адресация</h3></summary>
		Документированная возможность &ndash; регистр, используемый для косвенной
		адресации, содержит только целое неотрицательное число. Фактически
		значением его может быть любое число.
		Пусть число, которое содержится в регистре, который используется для
		косвенной адресации, записано в виде
		&plusmn;M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub>^&plusmn;P<sub>1</sub>P<sub>2</sub>,
		где M &ndash; цифры мантиссы, P &ndash; цифры порядка.
		При этом предполагается, что всегда 8 цифр мантиссы, просто последние
		могут быть нулевыми и обычно не отображаются.
		<p>
			При косвенном обращение сначала исходное число преобразуется по
			правилам, описанным ниже, а затем записывается обратно
			(для команд <span class="but_f">F</span><span class="op_f">FL0</span
			>&hellip;<span class="but_f">F</span><span class="op_f">FL3</span>
			иногда нет).
			При этом всегда(!) цифры M<sub>7</sub>M<sub>8</sub> преобразованного
			числа содержат адрес перехода (или номер регистра).
			Обратите внимание, что преобразованное число не нормализуется перед
			сохранением обратно, тем самым могут быть числа с ведущими нулями.
			Обычно это используется или для генерации специальных изображений или
			в комбинации с другими недокументированными операциями, которым важны
			только цифры мантиссы
			(пример в разделе <a href="#div_x2_exp_combine">Таинственный регистр X2</a>).
		</p>

		<details id="div_indirect_addr_gt1" open>
			<summary><h4>
				Вариант
				+M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub>^+P<sub>1</sub>P<sub>2</sub>
				, т.е. число больше или равно единицы (1.0 &les; N)
			</h4></summary>
			В этом случае к числу слева дописывается 7 &minus; P<sub>2</sub> нулей
			(только если результат неотрицательный), "выталкивая" остальную часть
			мантиссы право. Порядок числа (в нормализованном виде) при этом
			не меняется.
			<br>
			Для наглядности приведём таблицу преобразования на основе простой
			мантиссы, чтобы было видно, какие разряды куда попадают:
			<p></p>
			<table>
				<tr>
					<th>До</th>
					<th>7-P<sub>2</sub>
					<th>Нулей</th>
					<th>После</th>
					<th>Оно же</th>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">7</td>
					<td class="tdcenter">7</td>
					<td class="code">&nbsp;00000001.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;12.345678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">6</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;00000012.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;123.45678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">5</td>
					<td class="tdcenter">5</td>
					<td class="code">&nbsp;00000123.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1234.5678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">4</td>
					<td class="tdcenter">4</td>
					<td class="code">&nbsp;00001234.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;1234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;12345.678&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">3</td>
					<td class="tdcenter">3</td>
					<td class="code">&nbsp;00012345.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;12345.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;123456.78&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">2</td>
					<td class="tdcenter">2</td>
					<td class="code">&nbsp;00123456.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;123456.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1234567.8&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">1</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;01234567.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;1234567.&nbsp;&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;12345678.&nbsp;&nbsp;&nbsp;</td>
					<td class="tdcenter">0</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;12345678.&nbsp;&nbsp;&nbsp;</td>
					<td class="code">&nbsp;12345678.&nbsp;&nbsp;&nbsp;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;08</td>
					<td class="tdcenter">-1</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;08</td>
					<td class="code">&nbsp;1.2345678&nbsp;08</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;09</td>
					<td class="tdcenter">-2</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;09</td>
					<td class="code">&nbsp;1.2345678&nbsp;09</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;10</td>
					<td class="tdcenter">7</td>
					<td class="tdcenter">7</td>
					<td class="code">&nbsp;0.0000001&nbsp;17</td>
					<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;11</td>
					<td class="tdcenter">6</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;0.0000012&nbsp;17</td>
					<td class="code">&nbsp;1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11</td>
				</tr>
				<tr>
					<td colspan="5">&hellip;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;96</td>
					<td class="tdcenter">1</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;0.1234567&nbsp;97</td>
					<td class="code">&nbsp;1.234567&nbsp;&nbsp;96</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;97</td>
					<td class="tdcenter">0</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;97</td>
					<td class="code">&nbsp;1.2345678&nbsp;97</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;98</td>
					<td class="tdcenter">-1</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;98</td>
					<td class="code">&nbsp;1.2345678&nbsp;98</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678&nbsp;99</td>
					<td class="tdcenter">-2</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678&nbsp;99</td>
					<td class="code">&nbsp;1.2345678&nbsp;99</td>
				</tr>
			</table>
			<p>
				Кстати, это правило показывает, что для обычных целых чисел, порядок
				которых (от нуля) совпадает с числом цифр &minus; 1, слева
				дописывается такое число нулей, чтобы получилось 8 цифр.
				Т.е. число остается тем, что есть, что и соответствует документации.
				В случае, если кроме целой части есть и ещё и дробная, то же правило
				показывает, что дописываемые нули "вытеснят" дробную часть совсем,
				что часто используется в программах для сокращения: нет необходимости
				убирать дробную часть, т.к. косвенная адресация её сама уберёт.
			</p>
		</details>

		<details id="div_indirect_addr_lt1" open>
			<summary><h4>
				Вариант
				+M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub>^-P<sub>1</sub>P<sub>2</sub>
				, т.е. само число неотрицательное, но меньше единицы (0.0 &les; N &lt; 1.0)
			</h4></summary>
			В этом случае число дописываемых нулей определяется так. Вычисляется
			1P<sub>2</sub> &minus; 3, и если последняя цифра результата &lt; 8, то
			это и определяет число нулей. Иначе ничего не делается.
			<p></p>
			<table>
				<tr>
					<th>До</th>
					<th>1P<sub>2</sub>&minus;3</th>
					<th>Нулей</th>
					<th>После</th>
					<th>Оно же</th>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-01</td>
					<td class="tdcenter">8</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-01</td>
					<td class="code">&nbsp;1.2345678-01</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-02</td>
					<td class="tdcenter">9</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-02</td>
					<td class="code">&nbsp;1.2345678-02</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-03</td>
					<td class="tdcenter">10</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-03</td>
					<td class="code">&nbsp;1.2345678-03</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-04</td>
					<td class="tdcenter">11</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;0.1234567-03</td>
					<td class="code">&nbsp;1.234567&nbsp;-04</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-05</td>
					<td class="tdcenter">12</td>
					<td class="tdcenter">2</td>
					<td class="code">&nbsp;0.0123456-03</td>
					<td class="code">&nbsp;1.23456&nbsp;&nbsp;-05</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-06</td>
					<td class="tdcenter">13</td>
					<td class="tdcenter">3</td>
					<td class="code">&nbsp;0.0012345-03</td>
					<td class="code">&nbsp;1.2345&nbsp;&nbsp;&nbsp;-06</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-07</td>
					<td class="tdcenter">14</td>
					<td class="tdcenter">4</td>
					<td class="code">&nbsp;0.0001234-03</td>
					<td class="code">&nbsp;1.234&nbsp;&nbsp;&nbsp;&nbsp;-07</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-08</td>
					<td class="tdcenter">15</td>
					<td class="tdcenter">5</td>
					<td class="code">&nbsp;0.0000123-03</td>
					<td class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-09</td>
					<td class="tdcenter">16</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;0.0000012-03</td>
					<td class="code">&nbsp;1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-09</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-10</td>
					<td class="tdcenter">7</td>
					<td class="tdcenter">7</td>
					<td class="code">&nbsp;0.0000001-03</td>
					<td class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-10</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-11</td>
					<td class="tdcenter">8</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-11</td>
					<td class="code">&nbsp;1.2345678-11</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-12</td>
					<td class="tdcenter">9</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-12</td>
					<td class="code">&nbsp;1.2345678-12</td>
				</tr>
				<tr>
					<td colspan="5">&hellip;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-23</td>
					<td class="tdcenter">10</td>
					<td class="tdcenter">0</td>
					<td class="code">&nbsp;1.2345678-23</td>
					<td class="code">&nbsp;1.2345678-23</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-24</td>
					<td class="tdcenter">11</td>
					<td class="tdcenter">1</td>
					<td class="code">&nbsp;0.1234567-23</td>
					<td class="code">&nbsp;1.234567&nbsp;-24</td>
				</tr>
				<tr>
					<td colspan="5">&hellip;</td>
				</tr>
				<tr>
					<td class="code">&nbsp;1.2345678-99</td>
					<td class="tdcenter">16</td>
					<td class="tdcenter">6</td>
					<td class="code">&nbsp;0.0000012-93</td>
					<td class="code">&nbsp;1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-99</td>
				</tr>
			</table>
		</details>

		<details id="div_indirect_addr_negative" open>
			<summary><h4>
				Вариант
				-M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub>^&plusmn;P<sub>1</sub>P<sub>2</sub>
				, т.е. само число отрицательное (N &lt; 0.0)
			</h4></summary>
			В этом случае всё как указано выше, только дописываются не нули, а
			девятки. Знак самого числа сохраняется.
			<br>
			Пример:
			<span class="code">-123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
			перейдет в
			<span class="code">-99999123.&nbsp;&nbsp;&nbsp;</span>,
			т.е. адрес перехода = 23.
			<br>
			Пример:
			<span class="code">-1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>
			не измениться, т.е. адрес перехода будет равен нулю.
			<br>
			Пример:
			<span class="code">-1.2345678-08</span>
			станет как
			<span class="code">-9.9999123-03</span>, т.е. адрес перехода = 23.
			<p>
				Тут нужно сделать <strong>замечание</strong>. Есть предположение,
				что девятки не
				случайны, а равны 10 &minus; 1, где 10 это знак минус (как
				шестнадцатеричная цифра  A).
				Для проверки такого предположения возьмем число с цифрой вместо знака
				(см. <a href="#div_zero_digit">
					Числа, у которых вместо знака стоит цифра
				</a> для алгоритма получения).
				Например <span class="code">2E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				где двойка стоит на месте знака. При косвенной адресации:
				<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">9</span>.
				Двойка уменьшается на единицу и становится
				<span class="code">21111111E.&nbsp;&nbsp;&nbsp;</span>.
				Аналогично для других чисел, например, если для
				<span class="code">9E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
				(которое после <span class="but">/-/</span>) выполнить косвенную адресацию, то получим
				<span class="code">98888888E.&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Теперь рассмотрим ситуацию, когда само значение регистра ещё и меняется
				как описано в документации. Обращаю внимание, что изменения происходят
				не при любом косвенном обращении, а только когда значение адреса для
				перехода вычисляется. Например, в условном операторе
				<span class="but_k">К</span><span class="op_f">x&lt;0</span><span
				class="but">4</span> регистр R4 будет модифицирован только когда x&ges;0,
				т.е. когда понадобиться вычислить адрес перехода.
			</p>
		</details>

		<details id="div_indirect_addr_R0" open>
			<summary><h4>Регистры R0&hellip;R3</h4></summary>
			Для них преобразованное(!) значение
			предварительно уменьшается на 1 без(!) учета порядка и знака.
			В расчёт берутся только (но все) цифры мантиссы. При этом если
			был ноль, то преобразуется в -99999999.
			Из того, что знак не учитывается выходит, что для отрицательных чисел
			получается увеличение числа (в арифметическом смысле),
			а не уменьшение. Примеры:
			<p>
				<span class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				что представляется как 1.23^02, перейдет в 0.0000123^+07,
				затем уменьшится до 0.000012<strong>2</strong>^+07 и превратиться в
				<span class="code">&nbsp;00000122.&nbsp;&nbsp;&nbsp;</span>,
				т.е. адрес перехода = 22.
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>,
				что представляется как 1.2300000^-02 уменьшится до
				1.2<strong>299999</strong>^-02
				превратиться в <span class="code">&nbsp;1.2299999-02</span>,
				т.е. адрес перехода = 99.
				<br>
				<span class="code">-123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				что представляется как -1.23^+02, преобразуется в -9.9999123^+07,
				затем уменьшится до -9.999912<strong>2</strong>^+07, превратиться в
				<span class="code">-9.9999122.&nbsp;&nbsp;&nbsp;</span>,
				т.е. адрес перехода = 22.
				<br>
				<span class="code">-1.2345678-08</span>, преобразуется в -9.9999123^-03,
				затем уменьшится до -9.999912<strong>2</strong>^-03, превратиться в
				<span class="code">-9.9999122-03</span>, т.е. адрес перехода = 22.
			</p>
			<p>
				Обратите внимание, что при уменьшении мантиссы до нуля порядок числа
				сохраняется. Например, если исходно было 1.^-20, то после
				преобразования будет 0.0000001^-13, а после уменьшения станет
				0.000000<strong>0</strong>^-13, т.е.
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-13</span>.
				Правда такой ноль, кроме необычного вида, в операциях ничем от
				простого нуля не отличается. Но в сочетании с другими
				недокументированными возможностями, которые могут объединить
				мантиссу и порядок от разных чисел
				(см. <a href="#div_x2_exp_combine">Таинственный регистр X2</a>)
				это может пригодится.
				Таким же образом из 1.^90 получается
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;97</span>.
			</p>
		</details>

		<details id="div_indirect_addr_R4" open>
			<summary><h4>Регистры R4&hellip;R6</h4></summary>
			Для них преобразованное значение
			предварительно увеличивается на 1, так же без учета порядка и знака.
			При этом если было -99999999 (все девятки), то преобразуется в ноль.
			По  аналогии с замечания для отрицательных чисел, число
			+99999999 (все девятки) преобразуется в число с цифрой на месте знака:
			<span class="code">200000000.&nbsp;&nbsp;&nbsp;</span> (на месте знака
			стоит 2). Оно ведёт себя как обычный ноль. Примеры:
			<p>
				<span class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				что представляется как 1.23^+02, перейдет в 0.0000123^+07, затем
				увеличится до 0.000012<strong>4</strong>^+07 и превратиться в
				<span class="code">&nbsp;00000124.&nbsp;&nbsp;&nbsp;</span>, т.е.
				адрес перехода = 24.
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>,
				что представляется как 1.2300000^-02, увеличится до
				1.230000<strong>1</strong>^+02  превратиться в
				<span class="code">&nbsp;1.2300001-02</span>, т.е. адрес перехода = 01.
				<br>
				<span class="code">-123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				что представляется как -1.23^+02 преобразуется в -9.9999123^+07,
				затем увеличится до -9.999912<strong>4</strong>^+07, превратиться в
				<span class="code">-99999124.&nbsp;&nbsp;&nbsp;</span>,
				т.е. адрес перехода = 24.
				<br>
				<span class="code">-1.2345678-08</span>, преобразуется в -9.9999123^-03,
				затем увеличится до -9.999912<strong>4</strong>^-03, превратиться в
				<span class="code">-9.9999124-03</span>, т.е. адрес перехода = 24.
			</p>
		</details>

		<details id="div_indirect_addr_FL0" open>
			<summary><h4>
				Команды <span class="but_f">F</span><span class="op_f">FL0</span>&hellip;
				<span class="but_f">F</span><span class="op_f">FL3</span>
			</h4></summary>
			Для них действуют те же правила, что для
			регистров R0&hellip;R3, только перед уменьшением проверяется, что
			полученное число не равно единице (опять же без учета знака и порядка).
			В случае если получится единица, происходит завершение цикла и
			преобразованное значение НЕ записывается обратно в регистр. Примеры:
			<p>
				<span class="code">&nbsp;123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				что представляется как 1.23^+02, перейдет в 0.0000123^+07,
				затем уменьшится до 0.000012<strong>2</strong>^+07 и   превратиться в
				<span class="code">&nbsp;00000122.&nbsp;&nbsp;&nbsp;</span>,
				цикл продолжается.
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>,
				что представляется как 1.2300000^-02 уменьшится до 1.2299999^-02
				превратиться в <span class="code">&nbsp;1.2299999-02</span>,
				цикл продолжается.
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
				преобразуется в 00000001, равно единице &ndash; цикл завершиться, а
				исходное число не измениться, т.е. останется
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				<span class="code">&nbsp;1.23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-10</span>,
				что представляется как 1.23^-10, преобразуется до 0.0000001^-03,
				равно единице &ndash; цикл завершиться, а исходное число не измениться.
			</p>
			<p>
				Проверить "на единицу" исходное можно через регистры R7&hellip;Re.
				Если после
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">R</span>
				на экране мантисса будет 00000001 (и где-то точка), то значит
				цикл прервется на исходном числе.
			</p>
		</details>

		<details id="div_indirect_addr_mantissa" open>
			<summary><h4>Мантисса содержит шестнадцатеричные цифры</h4></summary>
			В этом случае <strong>уменьшение</strong> шестнадцатеричной цифры
			идёт до 9, а затем как обычно. При уменьшении ниже 0 идёт заём
			(уменьшение на 1 предыдущей, возможно так же шестнадцатеричной цифры),
			при это текущая цифра будет не F, а как обычно 9.
			<p>
				Переход так же будет на шестнадцатеричный адрес, но с этим мы уже
				знакомы
				(см. <a href="#div_addr_space">Программное адресное пространство</a>).
			</p>
			<p>
				К сожалению, если идёт <strong>увеличение</strong>, то число с
				шестнадцатеричными цифрами предварительно подвергается
				<a href="#div_glos_normalization">нормализации</a> (справа налево,
				смысл как указано в списке терминов):
				буквы считаются как двузначные, с переносом лишней единицы в
				старший разряд. Например, сложение числа 9AE и 1 будет так: E = 14,
				значит последняя цифра 4 + 1 = 5 и 1 «в уме»;
				затем A = 10 + 1 в уме, будет 11, т.е. 1 и 1 в уме;
				далее 9 + 1 = 10. Итого 1015. Это значит, что косвенная адресация
				через R4&hellip;R6 всегда уберёт шестнадцатеричные цифры из числа.
				При этом нестандартный знак числа (см. замечание в варианте для
				отрицательных чисел) остается.
			</p>
		</details>

		<details id="div_indirect_addr_exponent" open>
			<summary><h4>Порядок содержит шестнадцатеричные цифры</h4></summary>
			На самом деле без Еггогологии можно получить только 1.^&plusmn;HH,
			используя оператор
			<span class="but_f">F</span><span class="op_f">10ˣ</span>.
			<p>
				Для чисел вида 1.^+0H (одна цифра) никаких преобразований не
				производится, а значит адрес перехода всегда будет нулевым.
				Если идёт увеличение или уменьшение (через выбор регистра),
				то мантисса увеличивается или уменьшается в соответствии с правилами выше,
				а знак и порядок не меняется.
				Пример: если в регистр R0 записать
				<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0E</span>
				и выполнить
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span>,
				то результатом станет уменьшение мантиссы 100000000 до 09999999,
				т.е. <span class="code">&nbsp;0.9999999&nbsp;0E</span>.
			</p>
				Для чисел вида 1.^-0H (тоже одна цифра) так же никаких
				преобразований не производится. Единственное, хочу заострить внимание
				на значении такого числа. В этом случае порядок подразумевается
				по модулю 16, т.е. -E, это -14 или 2. Получается, что
				1.^-0E = 100, 1.^-0D = 1000, 1.^-0C = 10000, 1.^-0B = 100000, а...
				1.^-0A не получается (будет сразу 1.^-10, им и останется).
			<p>
			</p>
			<p>
				Для двузначных чисел порядка ситуация сложнее. Возьмем,
				для примера 1.^+B0
				(<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L0</span>).
				Кстати, 1.^+AA будет автоматически переведено в 1.^+B0,
				как и 1.^+0A будет автоматически переведено в 1.^+10
				(чем-то именно A не нравиться, для остальных цифр такого не замечено,
				хотя и тут можно обмануть, если для 1^.-LL набрать
				<span class="but">ВП</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">5</span>).
				Так вот, по сути это число равно 1.^+110. Как видно, вместо знака
				порядка используется цифра, но для ПМК это тоже, что и знак,
				поэтому будет применено правило для отрицательных порядков, то
				есть допишется слева 7 (= 10 &minus; 3 и меньше 8) нулей, что
				приведёт к 0.0000001^117.
				Т.е. в качестве адреса перехода будет 01, но само число из регистра
				уже лучше не извлекать, т.к. оно будет сверхчислом и на экране
				отображаться как ЕГГ0Г.
			</p>
			<p>
				Если у двузначных чисел порядок отрицательный, то срабатывает
				<strong>правило "сумма = 160"</strong>, это значит, что внутренне
				порядок меняется на
				число по модулю 160. Для примера, возьмем 1.^-C0
				(<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-C0</span>).
				Это эквивалентно 1.^-120, а по правилу "сумма = 160", как 1.^+40.
				Используя правило преобразования для чисел больше единицы, получаем,
				что число будет преобразовано в 0.0000001^+47, соответственно
				адрес перехода 01, а полученное после косвенной адресации число можно
				просто извлечь из регистра: будет
				<span class="code">&nbsp;0.0000001&nbsp;47</span>
				Для сравнения, если взять 1.^-C1, то правило "сумма = 160",
				приведёт к 1.^+39, что не поддаётся преобразованию (9 &gt; 7), а значит
				само число после косвенной адресации не измениться и останется
				<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-C1</span>
				(адрес перехода равен 00). И, да, к этому числу можно прибавить 0,
				чтобы увидеть
				<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;39</span>.
			</p>
			<p>
				У правила "сумма = 160" возникает ещё один интересный побочный эффект.
				Детали см. в разделе
				<a href="#div_neg_zero_degree">Числа с отрицательной нулевой степенью</a>.
			</p>
			<p>
				Если идёт увеличение или уменьшение (через выбор регистра), то мантисса
				увеличивается или уменьшается в соответствии с правилами,
				уже описанными выше.
			</p>
		</details>

		<details id="div_indirect_addr_reg" open>
			<summary><h4>Значение &ndash; номер регистра, а не адрес</h4></summary>
			Если косвенное значение представляет не адрес, а
			номер регистра, то его номер также определятся двумя последними
			цифрами, разбиваясь на два варианта,
			когда первая цифра нулевая, и когда нет:
			<table class="trcenter">
				<tr><th>Первая ноль</th><th>Первая НЕ ноль</th></tr>
				<tr><td>00&rarr;R0</td><td>#0&rarr;Ra</td></tr>
				<tr><td>01&rarr;R1</td><td>#1&rarr;Rb</td></tr>
				<tr><td>02&rarr;R2</td><td>#2&rarr;Rc</td></tr>
				<tr><td>03&rarr;R3</td><td>#3&rarr;Rd</td></tr>
				<tr><td>04&rarr;R4</td><td>#4&rarr;Re</td></tr>
				<tr><td>05&rarr;R5</td><td>#5&rarr;R0</td></tr>
				<tr><td>06&rarr;R6</td><td>#6&rarr;R0</td></tr>
				<tr><td>07&rarr;R7</td><td>#7&rarr;R1</td></tr>
				<tr><td>08&rarr;R8</td><td>#8&rarr;R2</td></tr>
				<tr><td>09&rarr;R9</td><td>#9&rarr;R3</td></tr>
				<tr><td>0A&rarr;Ra</td><td>#A&rarr;R4</td></tr>
				<tr><td>0B&rarr;Rb</td><td>#B&rarr;R5</td></tr>
				<tr><td>0C&rarr;Rc</td><td>#C&rarr;R6</td></tr>
				<tr><td>0D&rarr;Rd</td><td>#D&rarr;R7</td></tr>
				<tr><td>0E&rarr;Re</td><td>#E&rarr;R8</td></tr>
				<tr><td>0F&rarr;R0</td><td>#F&rarr;R9</td></tr>
			</table>
		</details>

		<details id="div_indirect_addr_using" open>
			<summary><h4>Практическое использование</h4></summary>
			Вот пример использования знаний косвенной адресации для
			номеров регистров: программа заполняет регистры R0&hellip;R3
			инвертированными случайными числами, при этом используется
			только один регистр R0.
			<p>
				<span class="code_num">00.</span><span class="but_cx">Сx</span>&ensp;
				<span class="code_num">01.</span><span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
				<span class="code_num">02.</span><span class="but_k">К</span><span class="op_k">СЧ</span>&ensp;
				<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
				<span class="code_num">04.</span><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
				<span class="code_num">05.</span><span class="but_b">П&rarr;x</span><span class="but">0</span>&ensp;
				<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">x&ge;0</span>&ensp;
				<span class="code_num">07.</span><span class="but">02</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			<p>
				Ещё практических советов. Уменьшение шестнадцатеричной цифры для БЗ-34
				было единственным способом из цифры E получить остальные цифры.
				В МК-61 с приходом бинарных операций стало проще, но т.к. первая цифра
				всё ещё не во власти этих операций, то через косвенную адресацию
				получается быстрее, чем через дробную часть и ввод порядка.
			</p>
			<p>
				Особенность не уменьшения числа по окончании цикла, с учетом того,
				что фактически число может сильно отличаться от единицы
				(см. пример выше) позволяет использовать команды FLx для быстрой
				проверки значения регистра с одновременным переходом при удаче/неудаче.
			</p>
		</details>
	</details>

	<hr>

	<details id="div_x2" open>
		<summary><h3>Таинственный регистр X2</h3></summary>
		Такой регистр действительно не упоминается в документации. В
		действительности этот тот регистр, содержимое которого отображается на
		дисплее при остановке ПМК. Поэтому его иногда называют <em>экранным</em> регистром.
		<p>
			В документации указано, что таковым является регистр X, но это не так.
			В режиме вычислений после каждой команды содержимое регистра X сразу же
			копируется в X2. И поэтому разницы между ними нет.
			При таком копировании производятся дополнительные проверки
			(например, на предмет переполнения).
			Видимо в целях экономии в программном режиме при выполнении
			большинства(!) команд такое копировании не производится.
			Более того (а это и есть самое полезное), некоторые команды позволяют
			сделать и обратное копирование.
		</p>

		<details id="div_x2_affect" open>
			<summary><h4>X2-влияющие команды</h4></summary>
			Для начала опишем список команд, которые копируют содержимое X в X2
			(после выполнения, конечно). Назовем такие команды
			<strong>X2-влияющие</strong>.
			<strong>Безусловно</strong> выполняют копирование X&rarr;X2 следующие команды:
			<ul>
				<li>
					ввод числа (после ввода каждой цифры, в том числе и разделителя
					<span class="but">.</span>)
				</li>
				<li style="padding: 3px 0">
					<span class="but">/-/</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_cx">Сx</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but">В&uarr;</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">Вx</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">С/П</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">В/О</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">П&rarr;x</span><span class="but">R</span> (R = 0&hellip;F)
				</li>
				<li style="padding: 3px 0">
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
					(R = 0&hellip;F)
				</li>
				<li style="padding: 3px 0">
					пустые операторы с кодами F0&hellip;FF
				</li>
				<li style="padding: 3px 0">
					все команды, генерирующие ошибку (в силу перехода в режим вычислений),
					например,
					27(<span class="but_k">К</span><span class="but">-</span>),
					28(<span class="but_k">К</span><span class="but">&times;</span>),
					29(<span class="but_k">К</span><span class="but">&divide;</span>),
					2B&hellip;2E, 3C и стандартные операции при генерации ошибок.
				</li>
			</ul>
			Выполняют копирование только <strong>при НЕ переходе на адрес</strong>
			следующие команды:
			<ul>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&lt;0</span>
					(команда <span class="but_k">К</span><span class="op_f">x&lt;0</span>
				 &ndash; никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x=0</span> (команда
					<span class="but_k">К</span><span class="op_f">x=0</span> &ndash;
					никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&ge;0</span> (команда
					<span class="but_k">К</span><span class="op_f">x&ge;0</span> &ndash;
					никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&ne;0</span> (команда
					<span class="but_k">К</span><span class="op_f">x&ne;0</span> &ndash;
					никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L0</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L1</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L2</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L3</span>
				</li>
			</ul>
			Для условных операторов это означает, что копирование X&rarr;X2
			производится, когда условие выполняется. Для циклов &ndash; когда
			цикл завершается.
			<p>
				Остальные операторы НЕ копируют X в X2. А это, например, означает, что
				регистр X во время таких операций может содержать сверхчисло
				(больше или равно 10<sup>100</sup>).
				При этом, конечно, нужно учитывать, чтобы команда сам по себе не делала
				такую проверку на переполнение.
				Например,
				<span class="but_f">F</span><span class="op_f">10ˣ</span> делает
				проверку параметра перед выполнением, а
				<span class="but_f">F</span><span class="op_f">x&sup2;</span>
				&ndash; нет.
				Для пояснения рассмотрим такую программу:
			</p>
			<p>
				<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="code_num">01.</span><span class="but">5</span>&ensp;
				<span class="code_num">02.</span><span class="but">0</span>&ensp;
				<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x=0</span>&ensp;
				<span class="code_num">06.</span><span class="but">07</span>&ensp;
				<span class="code_num">07.</span><span class="but_cx">Сx</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			<p>
				Можно увидеть, что на шаге 04 в регистре X возникает сверхчисло.
				Причем оператор
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x=0</span>
				не выполняется, т.е. идёт переход на адрес 07 (как адрес перехода).
				В соответствии с таблицей выше, в этом случае копирование X в X2
				не происходит, а значит, ошибки не должно возникать.
				В чем легко убедиться, запустив программ.
				Но если в программе заменить оператор на
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>,
				то условие уже будет выполняться, и будет выполняться копирование
				X в X2, которое приведёт к ошибке.
				Что также проверяется запуском программы.
			</p>
			<p>
				Хочу отметить, что команда <span class="but_b">В/О</span> также
				является X2-влияющей, т.е. если перед возвратом из подпрограммы
				в регистре X будет сверхчисло, то произойдёт остановка по ошибке,
				причем возврат успеет отработать.
			</p>
			<p>
				Всё это не имело бы практического смысла, если бы не было команд,
				которые делают обратное копирование X2&rarr;X.
			</p>
		</details>

		<details id="div_x2_point" open>
			<summary><h4>Команда <span class="but">.</span> (код 0A)</h4></summary>
			Данная команда в программном режиме восстанавливает в регистре X
			значение X2 (за исключением случая, когда идёт обычный ввод числа,
			например, 1.23, в этом случае поведение полностью соответствует
			документации и эквивалентно режиму вычислений). При этом содержимое
			стека не меняется. Также команда ничего не делает после X2-влияющей
			команды, но это и логично.
			На практике такую команду чаще всего используют для экономии регистров,
			реже &ndash; когда требуется ввод без изменения стека.
			<br>
			Пример: проверка битового флага и если его нет, то его установка.
			Пусть в R9 храниться некое число для работы с битами, а в R1 бит
			для проверки, тогда следующий фрагмент сначала сделает проверку
			доступности бита, а при недоступности, сделает его установку:
			<p>
				<span class="code_num">00.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">1</span>&ensp;
				<span class="code_num">02.</span><span class="but_k">К</span><span class="op_k">&and;</span>&ensp;
				<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>&ensp;
				<span class="code_num">05.</span><span class="but">77</span>&ensp;
				&hellip;&ensp;
				<span class="code_num">77.</span><span class="but">.</span>&ensp;
				<span class="code_num">78.</span><span class="but_k">К</span><span class="op_k">&or;</span>&ensp;
				<span class="code_num">79.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
			</p>
			<p>
				Получается, что оператор <span class="but">.</span> по адресу 77
				восстановит R1 в X без сдвига стека, что позволит сразу выполнить
				бинарную операцию. Обычно само значение из R1 "вычислено", а не
				храниться в регистре. Обратите внимание, что выбрана не X2-влияющая
				проверка с переходом.
			</p>
			<p>
				Ещё пример &ndash; использовать оператор <span class="but">.</span> как
				входной параметр подпрограммы, т.е. эта команда стоит первым оператором.
				В этом случае, например, после ввода пользователя (после команды
				<span class="but_b">С/П</span>, которая всегда копирует X в X2),
				сначала выполняются некие вычисления, не затрагивающие X2 (в том числе
				сохранение этих результатов в регистры), а затем вызов подпрограммы,
				которая таким образом "видит" ввод пользователя.
			</p>
		</details>

		<details id="div_x2_exp" open>
			<summary><h4>Команда <span class="but">ВП</span> (код 0C)</h4></summary>
			Для этой команды существуют несколько условий и правил восстановления.
			Обращаю внимание, что после X2-влияющей команды она ведёт себя как
			обычно (как документировано).  Причем, даже если она используется
			нестандартно (и выполнит некое восстановление), то всё равно после её
			выполнения ввод цифр будет восприниматься как ввод порядка.
			<ul>
				<li>
					<details id="div_x2_exp_SR" open>
						<summary>
							<h4>Восстановление X2 с отбрасыванием первой цифры</h4>
						</summary>
						Это выполняется после последовательности операторов
						<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
						<span class="but">ВП</span>,
						где R &ndash; любой регистр памяти. При этом текущее содержимое
						регистра X теряется, без изменения стека. Вместо
						<span class="but_b">x&rarr;П</span><span class="but">R</span>
						может быть и команда
						<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>.
						<p>
							Пример. Пусть нам нужно обработать ввод выбора пользователя для
							перемещения в некоем 3-ном лабиринте. Обычно используются клавиши
							2,4,6,8,&plusmn;5 (что соответствует направлению движения).
							Рассмотрим такую последовательность (в предположении, что выбор
							пользователя храниться в регистре R9 и значение 0 имеет ещё
							какой-то дополнительный смысл):
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
							<span class="code_num">01.</span><span class="but">2</span>&ensp;
							<span class="code_num">02.</span><span class="but">&divide;</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>&ensp;
							<span class="code_num">04.</span><span class="but">77</span>&ensp;
							<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">06.</span><span class="but">+</span>&ensp;
							<span class="code_num">07.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">08.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">09.</span><span class="but_f">F</span><span class="op_f">x=0</span>&ensp;
							<span class="code_num">10.</span><span class="but">55</span>&ensp;
							<span class="code_num">11.</span><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>
						</p>
						<p>
							Что здесь происходит? На шаге два мы получим одно из чисел
							1, 2, 3, 4, &plusmn;2.5 или 0. Условным оператором мы не только
							отсекаем вариант с нулем, но делаем X&rarr;X2. Далее к полученному
							числу сразу прибавляем <big>&pi;</big> и сохраняем в R9
							для дальнейшей косвенной
							адресации (пусть в R4&hellip;R7 хранятся коэффициенты умножения для
							выполнения движения).  Обращаю внимание, что тут использованы не
							X2-влияющие команды.  После команды <span class="but">ВП</span> мы
							"восстановим" в X то значение, что было после деления на шаге 02,
							только без первой цифры, т.е. ноль (для 1&hellip;4) или &plusmn;0.5,
							чтобы использовать это для последующего ветвления программы
							(умножение на коэффициент деления, а для &plusmn;0.5 можно будет
							взять знак числа и т.д.). Без использования <span class="but">ВП</span>
							потребовалось бы использовать или дополнительный
							регистр, или дополнительные команды по манипуляции со стеком.
						</p>
						<p>
							Дополнительные условия. <strong>Если</strong> содержимое X2
							равно <strong>нулю</strong>,
							то будет восстановлена <strong>единица</strong>.
						</p>
						<p>
							Если в момент восстановления (выполнения команды
							<span class="but">ВП</span>) содержимое
							регистра <strong>X меньше нуля</strong>,
							то вместо удаления первой цифры у числа X2,
							она будет <strong>заменена на 9</strong>.
							<br>
							Например, после выполнения программы
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">01.</span><span class="but">/-/</span>&ensp;
							<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">03.</span><span class="but">&times;</span>&ensp;
							<span class="code_num">04.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							на экране будет <span class="code">-9.1415926&nbsp;&nbsp;&nbsp;</span> в
							R9 будет -<big>&pi;</big> &times; <big>&pi;</big>
							(команда по адресу 01 X2-влияющая).
						</p>
						<p>
							С учетом знаний по <a href="#div_glos_zero_digit">знакоцифрам</a>
							можно провести более простое правило: эта последовательность
							при восстановлении X2 (если X2 не ноль) первую цифру меняет на
							знакоцифру числа в регистре X минус 1. Тогда для обычных
							чисел получается:
						</p>
						<ul>
							<li>
								Число больше нуля, знакоцифра равна единице, значит первая
								цифра заменяется на ноль, т.е. удаляется.
							</li>
							<li>
								Число меньше нуля, с минусом, знакоцифра равна 10 (A), значит
								цифра заменяется на 9
							</li>
						</ul>
					</details>
				</li>
				<li>
					<details id="div_x2_exp_combine" open>
						<summary>
							<h4>Восстановление X2 с заменой первой цифры
							на цифру из числа в X</h4>
						</summary>
						Как правило это наиболее интересная последовательность.
						Она позволяет нестандартно сочетать два числа.
						<p>
							Рассмотрим последовательность
							<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="but">ВП</span>.
							При этом <span class="but_k">К</span><span class="op_k">НОП</span> взята как
							более нейтральная, могут быть и другие не X2-влияющие команды,
							назовем это первой командой. Тут важно учитывать:
						</p>
						<ol>
							<li>
								В качестве образца первой цифры берётся содержимое X до(!)
								начала данной последовательности.
							</li>
							<li>
								Если вместо <span class="but_k">К</span><span class="op_k">НОП</span>
								стоит другая не X2-влияющая команда, то она выполняется, но
								результат её выполнения будет потерян. При этом стек
								будет иметь состояние как обычно после выполнения команды.
							</li>
							<li>
								Если первая команда &ndash; это переход на другой адрес, то она
								выполниться и последовательность с <span class="but">ВП</span>
								будет нарушена.
							</li>
							<li>
								Если первая команда генерит ошибку, то снова последовательность
								с <span class="but">ВП</span> будет нарушена.
							</li>
							<li>
								Если первая команда это
								<span class="but_b">x&rarr;П</span><span class="but">R</span>, то будет
								выполнено по правилу, описанному выше, с отбрасыванием первой цифры.
							</li>
						</ol>
						<p>
							Пример:
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">02.</span><span class="but_k">К</span><span class="op_k">ЗН</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">Вx</span>&ensp;
							<span class="code_num">04.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">07.</span><span class="but_b">С/П</span>
						</p>
						<p>
							В результате получим <span class="code">1.ELE-6Г9&nbsp;&nbsp;&nbsp;</span>.
							Тут дробная часть понятна &ndash; это инверсия числа <big>&pi;</big>
							которое
							сохраняется X2-влияющей командой по адресу 03. А интересна тут
							цифра 1 на первом месте, которая появилась в стеке по команде
							<span class="but_k">К</span><span class="op_k">ЗН</span>.
							Именно она подставляется вместо восьмерки при восстановлении.
						</p>
						<p>
							Интересно, что первой цифрой может быть и шестнадцатеричная, тем
							самым можно получить то, что в режиме вычислений трудно сделать.
							Например,
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">9</span>&ensp;
							<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
							<span class="code_num">03.</span><span class="but">5</span>&ensp;
							<span class="code_num">04.</span><span class="but">&times;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">06.</span><span class="but">/-/</span>&ensp;
							<span class="code_num">07.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">08.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">09.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">10.</span><span class="but">/-/</span>&ensp;
							<span class="code_num">11.</span><span class="but">9</span>&ensp;
							<span class="code_num">12.</span><span class="but">9</span>&ensp;
							<span class="code_num">13.</span><span class="but_b">С/П</span>
						</p>
						<p>
							Будет 10(!) "минусов".
							<span class="code">--.--------99</span>. Тут
							X2-влияющая команда по адресу 06 фиксирует 8.AAAAAAA
							(заодно добавляя минус), а оператор дробной части оставляет на
							первом месте тоже цифру A. Всё это последовательность с
							<span class="but">ВП</span> успешно объединяет, а порядок -99 в конце
							дописывается для красоты.
						</p>
						<p>
							Ещё пример. Пусть нужна подпрограмма, которая из первой цифры
							(целой части) дробного числа в регистре X делает букву.
							Например, 1&rarr;E, 2&rarr;D,&hellip; 4&rarr;A.
							В режиме вычислений для этого подошла бы последовательность
						</p>
						<p>
							<span class="code_num">00.</span><span class="but">1</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">02.</span><span class="but">+</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but">1</span>&ensp;
							<span class="code_num">07.</span><span class="but_k">К</span><span class="op_k">[x]</span>
						</p>
						<p>
							С учетом специфики выполнения команды <span class="but">ВП</span> в
							программном режиме нужно ещё скопировать X&rarr;X2 после команды
							<span class="but_k">К</span><span class="op_k">{x}</span>, т.е.
						</p>
						<p>
							<span class="code_num">00.</span><span class="but">1</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">02.</span><span class="but">+</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">05.</span><span class="but">В&uarr;</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">07.</span><span class="but">1</span>&ensp;
							<span class="code_num">08.</span><span class="but_k">К</span><span class="op_k">[x]</span>
						</p>
						<p>
							Это +1 команда, к тому же стек будет испорчен. Рассмотрим
						</p>
						<p>
							<span class="code_num">00.</span><span class="but">1</span>&ensp;
							<span class="code_num">01.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
							<span class="code_num">02.</span><span class="but">+</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>
						</p>
						<p>
							Здесь, благодаря восстановлению единицы (шаг 0), на шаге 06,
							останется только одна шестнадцатеричная цифра.
							Так недокументированная последовательность сделала подпрограмму
							короче на два шага.
						</p>
						<p>
							Нужно понимать, что если число в X2 не нормализовано, то всё равно
							заменяется первая цифра. Воспользуемся знаниями косвенной адресации:
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">4</span>&ensp;
							<span class="code_num">02.</span><span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span>&ensp;
							<span class="code_num">04.</span><span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">07.</span><span class="but_b">С/П</span>
						</p>
						<p>
							В данном случае 4 после косвенного перехода становится 00000004,
							а значит замена первой цифры приведёт к
							<span class="code">&nbsp;40000004.&nbsp;&nbsp;&nbsp;</span>,
							в чем легко убедиться, запустив программу.
						</p>
						<p>
							Теперь рассмотрим особенности. Если число <strong>X</strong>
							до начала последовательности <strong>было нулем</strong>, то
							вместо первой цифры
							устанавливается ноль. Обычно это значит, что число будет без первой
							цифры (начальный ноль не значащий). Но если он уже и так там был
							(например, число &ndash; это результат косвенной адресации с
							ведущими нулями), тогда никаких полезных действий не будет.
							Впрочем, иногда, именно это различие можно использовать, чтобы
							узнать, выполнялась ли косвенная адресация или нет.
						</p>
						<p>
							Если <strong>X2 нулевое</strong>, то тут как бы проявляется
							известный трюк с <span class="but">ВП</span>, который 0
							превращает в 1.
							В данном случае первая цифра числа X увеличивается на 1. Вот фрагмент:
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">03.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							Если на вход этой программе дать 5, то выдаст 6. А если 9, то
							выдаст&hellip; A(!), потом аналогично B, C, D, E, F. Впрочем,
							последнее лучше тут же заменить на 0 и прочистить стек &ndash;
							пустышки коварны (во всяком случае, если на вход передать F, то
							программа однозначно будет перекручена во что-то неузнаваемое).
							Ещё пример:
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">С/П</span>
						</p>
						<p>
							На вход
							<span class="code">-9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
							на выходе первая цифра от обратной величины
							<span class="code">-1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
						</p>
					</details>
				</li>
				<li>
					<details id="div_x2_exp_goto" open>
						<summary>
							<h4><span class="but">ВП</span> сразу после косвенного перехода</h4>
						</summary>
						Т.е. в программе делается переход через команду
						<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
						или переход при проверке условия, например,
						<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
						и сразу в месте, куда выполнился переход идёт команда
						<span class="but">ВП</span>.
						В этом случае также идёт восстановление X2, но при этом
						<strong>первая	цифра меняется на 7</strong>.
						Знак и порядок сохраняются. Аналогично
						тому, что и ранее, если число в X2 не нормализовано,
						то всё равно идёт замена первой цифры, оставляя остальные как есть.
						В случае <strong>X2 = 0</strong> число будет
						восстановлено <strong>как 8</strong>.
						<p>
							Для условных переходов это работает только если идёт переход на
							адрес. Если же условие выполняется (т.е. без перехода),
							то поведение будет как указано выше (фактически команда будет
							проигнорирована). Если первая после перехода не
							<span class="but">ВП</span>, то тоже по правилам для
							<span class="but">ВП</span> ранее.  Пример.
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class="code_num">02.</span><span class="but">0</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">x&rarr;П</span><span class="but">8</span>&ensp;
							<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="but_b">БП</span><span class="but">8</span>&ensp;
							&hellip;&ensp;
							<span class="code_num">10.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">11.</span><span class="but_b">С/П</span>
						</p>
						<p>
							После остановке на экране будет
							<span class="code">&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
							т.е. восстановлено X2 = 10 (вместо 100), и первая цифра заменена на 7.
							Ещё пример.
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">02.</span><span class="but">8</span>&ensp;
							<span class="code_num">03.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">04.</span><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
							<span class="code_num">05.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
							<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">07.</span><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span>&ensp;
							<span class="code_num">08.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">09.</span><span class="but_b">С/П</span>
						</p>
						<p>
							По уже указанными правилам будет
							<span class="code">&nbsp;70000008.&nbsp;&nbsp;&nbsp;</span>. Если
							заменить команду по адресу 07 на
							<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span>,
							то ничего не измениться, т.к. условие не выполниться и будет переход.
							Но если заменить на
							<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">9</span>,
							то уже условие выполниться, перехода не будет, и сработает старое
							правило, т.е. будет использована первая цифра числа в X, т.е.
							<span class="code">&nbsp;30000008.&nbsp;&nbsp;&nbsp;</span>.
						</p>
					</details>
				</li>
				<li>
					<details id="div_x2_exp_plus" open>
						<summary>
							<h4>Использование <span class="but">ВП</span> как сложение</h4>
						</summary>
						Редкий случай, скорее для информации только. Последовательность
						<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but">ВП</span>.
						При нулевом значении X2, сначала, как и описывалось ранее, увеличит X
						на единицу, а второе <span class="but">ВП</span> уже на величину
						цифры, которая была до увеличения. Последующие добавления
						<span class="but">ВП</span> уже ничего не меняют. Пример:
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">0</span>&ensp;
							<span class="code_num">02.</span><span class="but">&lt;-&gt;</span>&ensp;
							<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">04.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">05.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">06.</span><span class="but_b">С/П</span>
						</p>
						<p>
							На вход 6, на выходе D (6 + 7 = 13). На вход D, на выходе
							B (13 + 14 = 27 = 16 + 11).
						</p>
					</details>
				</li>
				<li>
					<details id="div_x2_exp_down" open>
						<summary>
							<h4>Команда <span class="but">.</span> перед <span class="but">ВП</span>
							"сдвигает" захват X глубже на начало</h4>
						</summary>
						Обычно команда <span class="but">.</span> восстанавливает в X значение
						X2, но <span class="but">ВП</span> тоже пытается восстановить X2,
						но 1-ю цифру берёт ту, что было за 2 хода в до нее в X. Рассмотрим
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class="code_num">02.</span><span class="but">5</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
							<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">.</span>&ensp;
							<span class="code_num">07.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">08.</span><span class="but_b">С/П</span>
						</p>
						<p>
							Результат 55, потому что
							15&sup2; = 225, 225&sup2; = <strong>5</strong>0625 и «выигрывает»
							<span class="but">ВП</span>, который восстановит X2(15), с первой
							цифрой 5. Если убрать второй
							<span class="but_k">К</span><span class="op_k">НОП</span>, то
							результат будет 25 (2 от 225), т.е. второй
							<span class="but_f">F</span><span class="op_f">x&sup2;</span>
							будет проигнорирован, как будто команда
							<span class="but">.</span> отодвинула
							<span class="but">ВП</span> вглубь.
							Если поменять
							<span class="but_k">К</span><span class="op_k">НОП</span> и
							<span class="but">.</span> местами, то будет 15, т.к.
							<span class="but">.</span> восстановит 15 и уже с ним работает
							<span class="but">ВП</span>, как в ручном режиме.
							Другой пример:
						</p>
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">01.</span><span class="but">1</span>&ensp;
							<span class="code_num">02.</span><span class="but">5</span>&ensp;
							<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
							<span class="code_num">04.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="code_num">05.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
							<span class="code_num">06.</span><span class="but">.</span>&ensp;
							<span class="code_num">07.</span><span class="but">ВП</span>&ensp;
							<span class="code_num">08.</span><span class="but_b">С/П</span>
						</p>
						<p>
							Здесь <span class="but">.</span> отодвигает до
							<span class="but_b">x&rarr;П</span><span class="but">9</span>,
							т.е. восстановится 15 с цифрой 3, т.е. 35. Если убрать
							<span class="but_k">К</span><span class="op_k">НОП</span>, то
							поведение будет как у
							<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
							<span class="but">ВП</span>, т.е. 15 без первой цифры (5)".
						</p>
					</details>
				</li>
			</ul>
		</details>

		<details id="div_x2_sum" open>
			<summary><h4>Итог</h4></summary>
			Причиной нестандартного поведения команд
			<span class="but">ВП</span> и <span class="but">.</span> является то, что
			подпрограммы ввода числа в ПМК, в том числе его порядка,
			работают напрямую с регистром X2.
			Рассмотрим пример, который затрагивает другую команду ввода числа:
			<p>
				<span class="code_num">01.</span><span class="but">B&uarr;</span>&ensp;
				<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
				<span class="code_num">03.</span><span class="but">2</span>&ensp;
				<span class="code_num">04.</span><span class="but">/-/</span>&ensp;
				<span class="code_num">05.</span><span class="but_b">С/П</span>
			</p>
			Очевидно, что тут произойдёт деление на 100. Этот код ведёт себя в
			соответствии с документацией.  Немного дополним его:
			<p>
				<span class="code_num">01.</span><span class="but">B&uarr;</span>&ensp;
				<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
				<span class="code_num">03.</span><span class="but">2</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">07.</span><span class="but">/-/</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			Если посмотреть, выглядит так, что после ввода порядка (умножения на 100)
			мы берем ещё <big>&pi;</big>, два раза возводим его в квадрат, а затем делаем
			отрицательным. На самом деле это фрагмент делает то же, что и первый!
			Операции ввода числа работают с X2, в промежутке все команды &ndash; не
			X2-влияющие, они, конечно, будут выполнены, но результат будет отброшен
			при выполнении команды <span class="but">/-/</span>, которая продолжит ввод
			числа (в данном случае порядка) в регистре X2.
			То, что промежуточные команды выполнялись, можно узнать по содержимому
			стека &ndash; в регистре Y будет входное значение, умноженное на 100,
			а в X1 &ndash; квадрат от <big>&pi;</big>.
			<p>
				Ещё пример. Известно (хотя не документировано), что для запрета ввода
				точки при вводе порядка, сочетание команд <span class="but">ВП</span> и
				<span class="but">.</span> генерит ошибку. Более того, в отличии от остальных
				способов получения ошибки он отличается тем, что
			</p>
			<ol>
				<li>Он самый быстрый, действует мгновенно, а не "задумываясь".</li>
				<li>
					Он не пропускает в программном режиме лишнюю команду, как делают
					все остальные операции, вызывающие ошибку (ах да, это тоже не
					документировано).
				</li>
			</ol>
			<p>
				Но это сочетание также работает с X2, т.е. игнорирует все не X2-влияющие
				команды. В связи с этим становится ясно, что следующий фрагмент:
			</p>
			<p>
				<span class="code_num">01.</span><span class="but">B&uarr;</span>&ensp;
				<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">03.</span><span class="but">ВП</span>&ensp;
				<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">06.</span><span class="but">.</span>&ensp;
				<span class="code_num">07.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span>
			</p>
			остановится по ошибке уже на команде <span class="but">.</span> (т.е. следующим
			для исполнения будет адрес 07) и успеет возвести в квадрат только дважды
			(первый квадрат, как не X2-влияющий будет отброшен по команде
			<span class="but">ВП</span>).
		</details>
	</details>

	<hr>

	<details id="div_hex" open>
		<summary><h3>Шестнадцатеричная арифметика</h3></summary>
		Речь идёт об обычных арифметических операциях, но в ситуации, когда
		операнд представляет собой число, содержащее шестнадцатеричные цифры
		A&hellip;E (F убрано из рассмотрения как опасное, по крайней мере в качестве
		первой цифры).
		<p>
			Для простоты рассмотрим ситуации, когда число состоит из одной
			шестнадцатеричной цифры. Далее будем её обозначать буквой H. Для более
			ясного порядка операндов будем использовать стандартные обозначения X и Y.
		</p>

		<details id="div_hex_h_plus_y" open>
			<summary><h4>Операция H <span class="but">+</span> Y</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>1</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>2</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>0</td>
				</tr>
				<tr>
					<th>3</th>
					<td>3</td><td>4</td><td>5</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>4</td><td>5</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>5</th>
					<td>5</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>6</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>7</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>8</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
				</tr>
				<tr>
					<th>A</th>
					<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
				</tr>
				<tr>
					<th>B</th>
					<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
				</tr>
				<tr>
					<th>C</th>
					<td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
				</tr>
				<tr>
					<th>D</th>
					<td>7</td><td>8</td><td>9</td><td>10</td><td>11</td>
				</tr>
				<tr>
					<th>E</th>
					<td>8</td><td>9</td><td>10</td><td>11</td><td>12</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>10</td><td>21</td><td>22</td><td>24</td><td>24</td>
				</tr>
				<tr>
					<th>11</th>
					<td>21</td><td>22</td><td>23</td><td>24</td><td>25</td>
				</tr>
				<tr>
					<th>12</th>
					<td>22</td><td>23</td><td>24</td><td>25</td><td>26</td>
				</tr>
				<tr>
					<th>13</th>
					<td>23</td><td>24</td><td>25</td><td>26</td><td>27</td>
				</tr>
				<tr>
					<th>14</th>
					<td>24</td><td>25</td><td>26</td><td>27</td><td>28</td>
				</tr>
				<tr>
					<th>15</th>
					<td>25</td><td>26</td><td>27</td><td>28</td><td>29</td>
				</tr>
				<tr>
					<th>16</th>
					<td>26</td><td>27</td><td>28</td><td>29</td><td>30</td>
				</tr>
				<tr>
					<th>17</th>
					<td>27</td><td>28</td><td>29</td><td>30</td><td>31</td>
				</tr>
				<tr>
					<th>18</th>
					<td>28</td><td>29</td><td>30</td><td>31</td><td>32</td>
				</tr>
				<tr>
					<th>19</th>
					<td>29</td><td>30</td><td>31</td><td>32</td><td>33</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>30</td><td>31</td><td>32</td><td>33</td><td>34</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>31</td><td>32</td><td>33</td><td>34</td><td>35</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>32</td><td>33</td><td>34</td><td>35</td><td>20</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>33</td><td>34</td><td>35</td><td>20</td><td>21</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>34</td><td>35</td><td>20</td><td>21</td><td>22</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>35</td><td>20</td><td>21</td><td>22</td><td>23</td>
				</tr>
			</table>
			<p>
				Вычисление идёт как шестнадцатеричное, остаток по модулю 16, а от
				него берётся последняя цифра (чтобы осталась одна).
				X = ((X + Y) mod 16) mod 10.
				<br>
				Если <strong>Y двузначное</strong>, то уже две цифры X = ((X + Y) mod 256)
				mod 100, а значит получается <strong>как
				обычное сложение</strong>, если число двузначное.
				<br>
				Если <strong>Y дробное</strong>, то целая часть как выше,
				а дробная сохраняется.
			</p>
		</details>

		<details id="div_hex_x_plus_h" open>
			<summary><h4>Операция X <span class="but">+</span> H</h4></summary>
			В этом случае осуществляется обычное сложение, только результат
			нормализуется. Например: 0 + A = 10, 9 + E = 23. В случае
			шестнадцатеричного X см. таблицу выше.
		</details>

		<details id="div_hex_y_minus_h" open>
			<summary><h4>Операция Y <span class="but">-</span> H</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>-10</td><td>-1</td><td>-2</td><td>-3</td><td>-4</td>
				</tr>
				<tr>
					<th>1</th>
					<td>-9</td><td>-10</td><td>-1</td><td>-2</td><td>-3</td>
				</tr>
				<tr>
					<th>2</th>
					<td>-8</td><td>-9</td><td>-10</td><td>-1</td><td>-2</td>
				</tr>
				<tr>
					<th>3</th>
					<td>-7</td><td>-8</td><td>-9</td><td>-10</td><td>-1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>-6</td><td>-7</td><td>-8</td><td>-9</td><td>-10</td>
				</tr>
				<tr>
					<th>5</th>
					<td>-5</td><td>-6</td><td>-7</td><td>-8</td><td>-9</td>
				</tr>
				<tr>
					<th>6</th>
					<td>-4</td><td>-5</td><td>-6</td><td>-7</td><td>-8</td>
				</tr>
				<tr>
					<th>7</th>
					<td>-3</td><td>-4</td><td>-5</td><td>-6</td><td>-7</td>
				</tr>
				<tr>
					<th>8</th>
					<td>-2</td><td>-3</td><td>-4</td><td>-5</td><td>-6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>-1</td><td>-2</td><td>-3</td><td>-4</td><td>-5</td>
				</tr>
				<tr>
					<th>A</th>
					<td>0</td><td>-1</td><td>-2</td><td>-3</td><td>-4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>1</td><td>0</td><td>-1</td><td>-2</td><td>-3</td>
				</tr>
				<tr>
					<th>C</th>
					<td>2</td><td>1</td><td>0</td><td>-1</td><td>-2</td>
				</tr>
				<tr>
					<th>D</th>
					<td>3</td><td>2</td><td>1</td><td>0</td><td>-1</td>
				</tr>
				<tr>
					<th>E</th>
					<td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>0</td><td>15</td><td>14</td><td>13</td><td>12</td>
				</tr>
				<tr>
					<th>11</th>
					<td>1</td><td>16</td><td>15</td><td>14</td><td>13</td>
				</tr>
				<tr>
					<th>12</th>
					<td>2</td><td>17</td><td>16</td><td>15</td><td>14</td>
				</tr>
				<tr>
					<th>13</th>
					<td>3</td><td>18</td><td>17</td><td>16</td><td>15</td>
				</tr>
				<tr>
					<th>14</th>
					<td>4</td><td>19</td><td>18</td><td>17</td><td>16</td>
				</tr>
				<tr>
					<th>15</th>
					<td>5</td><td>20</td><td>19</td><td>18</td><td>17</td>
				</tr>
				<tr>
					<th>16</th>
					<td>6</td><td>21</td><td>20</td><td>19</td><td>18</td>
				</tr>
				<tr>
					<th>17</th>
					<td>7</td><td>22</td><td>21</td><td>20</td><td>19</td>
				</tr>
				<tr>
					<th>18</th>
					<td>8</td><td>23</td><td>22</td><td>21</td><td>20</td>
				</tr>
				<tr>
					<th>19</th>
					<td>9</td><td>24</td><td>23</td><td>22</td><td>21</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>0</td><td>25</td><td>24</td><td>23</td><td>22</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>1</td><td>10</td><td>25</td><td>24</td><td>23</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>2</td><td>11</td><td>10</td><td>25</td><td>24</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>3</td><td>12</td><td>11</td><td>10</td><td>25</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>4</td><td>13</td><td>12</td><td>11</td><td>10</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>5</td><td>14</td><td>13</td><td>12</td><td>11</td>
				</tr>
			</table>
			<p>
				Выглядит похоже на X = (Y &minus; X) mod 16, но не всегда понятно,
				когда
				берётся заём, а когда нет. Число A какое-то особенное для двузначных.
				<br>
				Для трех- и выше значных повторяется как для двузначных,
				т.е. 100 &minus; A = 90, 100 &minus; B = 105,&hellip; ,
				109 &minus; E = 111.
			</p>
		</details>

		<details id="div_hex_h_minus_x" open>
			<summary><h4>Операция H <span class="but">-</span> X</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>10</td><td>11</td><td>12</td><td>13</td><td>14</td>
				</tr>
				<tr>
					<th>1</th>
					<td>9</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>2</th>
					<td>8</td><td>9</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>3</th>
					<td>7</td><td>8</td><td>9</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>6</td><td>7</td><td>8</td><td>9</td><td>0</td>
				</tr>
				<tr>
					<th>5</th>
					<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
				</tr>
				<tr>
					<th>6</th>
					<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
				</tr>
				<tr>
					<th>7</th>
					<td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
				</tr>
				<tr>
					<th>8</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>A</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>-1</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>C</th>
					<td>-2</td><td>-1</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>D</th>
					<td>-3</td><td>-2</td><td>-1</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>E</th>
					<td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>11</th>
					<td>-1</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>12</th>
					<td>-2</td><td>-1</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>13</th>
					<td>-3</td><td>-2</td><td>-1</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>14</th>
					<td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>0</td>
				</tr>
				<tr>
					<th>15</th>
					<td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td>
				</tr>
				<tr>
					<th>16</th>
					<td>-6</td><td>-5</td><td>-4</td><td>-3</td><td>-2</td>
				</tr>
				<tr>
					<th>17</th>
					<td>-7</td><td>-6</td><td>-5</td><td>-4</td><td>-3</td>
				</tr>
				<tr>
					<th>18</th>
					<td>-8</td><td>-7</td><td>-6</td><td>-5</td><td>-4</td>
				</tr>
				<tr>
					<th>19</th>
					<td>-9</td><td>-8</td><td>-7</td><td>-6</td><td>-5</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>-10</td><td>-9</td><td>-8</td><td>-7</td><td>-6</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>-1</td><td>-10</td><td>-9</td><td>-8</td><td>-7</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>-2</td><td>-1</td><td>-10</td><td>-9</td><td>-8</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>-3</td><td>-2</td><td>-1</td><td>-10</td><td>-9</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>-4</td><td>-3</td><td>-2</td><td>-1</td><td>-10</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td>
				</tr>
			</table>
			<p>
				Нарушения обычного вычитания только для нескольких чисел (выше и
				правее, начиная с B &minus; 1, для двузначных ниже и левее A &minus; 1B).
				<br>
				Кстати, особенность: когда из шестнадцатеричного числа вычитается
				его десятичный аналог, то ноль, на самом деле, не нормализованный
				(т.е. из 4-х значного будет 0000), и это можно использовать
				для получения нуля в любой степени. Пример (в ручном режиме):
			</p>
			<ol>
				<li>
					Получим цифру E документированным образом:
					<span class="but">1</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
					<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
					<span class="but">ВП</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">[x]</span>,
					или можно нестандартным:
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&times;</span>&ensp;
					<span class="but">ВП</span>
				</li>
				<li>
					Добавим порядок, который хотим получить:
					<span class="but">ВП</span>&ensp;
					<span class="but">9</span>&ensp;
					<span class="but">9</span>
				</li>
				<li>
					Затем скопируем в стек:
					<span class="but">В&uarr;</span>&ensp;
					<span class="but">В&uarr;</span>&ensp;
					<span class="but_cx">СX</span>
				</li>
				<li>
					Выполним сложение (с нулем) и вычитание:
					<span class="but">+</span>&ensp;
					<span class="but">-</span>
				</li>
			</ol>
			<p>
				И вот мы получили
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;99</span>.
			</p>
		</details>

		<details id="div_hex_h_mult_y" open>
			<summary><h4>Операция H <span class="but">&times;</span> Y</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<th>1</th>
					<td>10</td><td>10</td><td>10</td><td>10</td><td>0</td>
				</tr>
				<tr>
					<th>2</th>
					<td>20</td><td>20</td><td>20</td><td>20</td><td>0</td>
				</tr>
				<tr>
					<th>3</th>
					<td>30</td><td>30</td><td>30</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<th>4</th>
					<td>40</td><td>40</td><td>40</td><td>40</td><td>0</td>
				</tr>
				<tr>
					<th>5</th>
					<td>50</td><td>50</td><td>50</td><td>50</td><td>0</td>
				</tr>
				<tr>
					<th>6</th>
					<td>60</td><td>60</td><td>60</td><td>60</td><td>0</td>
				</tr>
				<tr>
					<th>7</th>
					<td>70</td><td>70</td><td>70</td><td>70</td><td>0</td>
				</tr>
				<tr>
					<th>8</th>
					<td>80</td><td>80</td><td>80</td><td>80</td><td>0</td>
				</tr>
				<tr>
					<th>9</th>
					<td>90</td><td>90</td><td>90</td><td>90</td><td>0</td>
				</tr>
				<tr>
					<th>A</th>
					<td>00</td><td>00</td><td>00</td><td>00</td><td>0</td>
				</tr>
				<tr>
					<th>B</th>
					<td>10</td><td>10</td><td>10</td><td>10</td><td>0</td>
				</tr>
				<tr>
					<th>C</th>
					<td>20</td><td>20</td><td>20</td><td>20</td><td>0</td>
				</tr>
				<tr>
					<th>D</th>
					<td>30</td><td>30</td><td>30</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<th>E</th>
					<td>40</td><td>40</td><td>40</td><td>40</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>100&nbsp;</td><td>100</td><td>100</td><td>100</td><td>0</td>
				</tr>
				<tr>
					<th>11</th>
					<td>110</td><td>110</td><td>110</td><td>110</td><td>0</td>
				</tr>
				<tr>
					<th>12</th>
					<td>120</td><td>120</td><td>120</td><td>120</td><td>0</td>
				</tr>
				<tr>
					<th>13</th>
					<td>130</td><td>130</td><td>130</td><td>130</td><td>0</td>
				</tr>
				<tr>
					<th>14</th>
					<td>140</td><td>140</td><td>140</td><td>140</td><td>0</td>
				</tr>
				<tr>
					<th>15</th>
					<td>150</td><td>150</td><td>150</td><td>150</td><td>0</td>
				</tr>
				<tr>
					<th>16</th>
					<td>160</td><td>160</td><td>160</td><td>160</td><td>0</td>
				</tr>
				<tr>
					<th>17</th>
					<td>170</td><td>170</td><td>170</td><td>170</td><td>0</td>
				</tr>
				<tr>
					<th>18</th>
					<td>180</td><td>180</td><td>180</td><td>180</td><td>0</td>
				</tr>
				<tr>
					<th>19</th>
					<td>190</td><td>190</td><td>190</td><td>190</td><td>0</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>200</td><td>200</td><td>200</td><td>200</td><td>0</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>210</td><td>210</td><td>210</td><td>210</td><td>0</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>220</td><td>220</td><td>220</td><td>220</td><td>0</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>230</td><td>230</td><td>230</td><td>230</td><td>0</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>240</td><td>240</td><td>240</td><td>240</td><td>0</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>250</td><td>250</td><td>250</td><td>250</td><td>0</td>
				</tr>
			</table>
			<p>
				Поразительное однообразие, почти все ведут себя как 10. Не ясно, чем
				так отличается E, но ноль получается и для многозначных чисел.
				<br>
				Для двузначных соответственно, т.е. C &times; 20 = 200, но E &times; 20 = 0.
			</p>
		</details>

		<details id="div_hex_x_mult_h" open>
			<summary><h4>Операция X <span class="but">&times;</span> H</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<th>1</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>2</th>
					<td>4</td><td>6</td><td>8</td><td>10</td><td>12</td>
				</tr>
				<tr>
					<th>3</th>
					<td>4</td><td>1</td><td>4</td><td>23</td><td>10</td>
				</tr>
				<tr>
					<th>4</th>
					<td>8</td><td>2</td><td>0</td><td>20</td><td>24</td>
				</tr>
				<tr>
					<th>5</th>
					<td>50</td><td>11</td><td>32</td><td>53</td><td>42</td>
				</tr>
				<tr>
					<th>6</th>
					<td>0</td><td>22</td><td>44</td><td>50</td><td>40</td>
				</tr>
				<tr>
					<th>7</th>
					<td>10</td><td>33</td><td>40</td><td>63</td><td>54</td>
				</tr>
				<tr>
					<th>8</th>
					<td>20</td><td>44</td><td>52</td><td>60</td><td>68</td>
				</tr>
				<tr>
					<th>9</th>
					<td>30</td><td>55</td><td>64</td><td>73</td><td>82</td>
				</tr>
				<tr>
					<th>A</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>B</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>C</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>D</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>E</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>11</th>
					<td>10</td><td>21</td><td>32</td><td>43</td><td>54</td>
				</tr>
				<tr>
					<th>12</th>
					<td>04</td><td>16</td><td>28</td><td>40</td><td>52</td>
				</tr>
				<tr>
					<th>13</th>
					<td>14</td><td>11</td><td>24</td><td>53</td><td>50</td>
				</tr>
				<tr>
					<th>14</th>
					<td>08</td><td>22</td><td>20</td><td>50</td><td>4</td>
				</tr>
				<tr>
					<th>15</th>
					<td>990</td><td>021</td><td>052</td><td>923</td><td>922</td>
				</tr>
				<tr>
					<th>16</th>
					<td>000</td><td>032</td><td>904</td><td>920</td><td>920</td>
				</tr>
				<tr>
					<th>17</th>
					<td>010</td><td>043</td><td>900</td><td>933</td><td>934</td>
				</tr>
				<tr>
					<th>18</th>
					<td>020</td><td>054</td><td>912</td><td>930</td><td>948</td>
				</tr>
				<tr>
					<th>19</th>
					<td>030</td><td>905</td><td>924</td><td>943</td><td>962</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
			</table>
			<p>
				Тут уже трудно поддаётся логике.
				На практике автор как-то использовал D. С одной стороны, это
				изображение, с другой &ndash; коэффициент 10 (см. таблицу H &times; Y),
				а самое основное &ndash; это проверка битового сдвига. При умножении
				дробной части, содержащей 1, 2, 4, 8 (как бы биты) возможен выход
				за диапазон, т.е. 0.5 или 1.6. Так вот, при умножении на D по
				указанной таблице, результат получался из одной цифры, если всё
				нормально, или из двух, при выходе за диапазон.
			</p>
			<p>
				Для двухзначных результат бывает не нормализованным: обратите
				внимание на ведущие нули в некоторых случаях. На этом фоне
				14 &times; E выглядит как белая ворона.
			</p>
		</details>

		<details id="div_hex_h_div_x" open>
			<summary><h4>Операция H <span class="but">&divide;</span> X</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td>
				</tr>
				<tr>
					<th>1</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>2</th>
					<td>5</td><td>5.5</td><td>6</td><td>6.5</td><td>7</td>
				</tr>
				<tr>
					<th>3</th>
					<td>3.3333333</td><td>3.6666666</td><td>4</td><td>4.3333333</td><td>4.6666666</td>
				</tr>
				<tr>
					<th>4</th>
					<td>2.5</td><td>2.75</td><td>3</td><td>3.25</td><td>3.5</td>
				</tr>
				<tr>
					<th>5</th>
					<td>2</td><td>2.2</td><td>2.4</td><td>2.6</td><td>2.8</td>
				</tr>
				<tr>
					<th>6</th>
					<td>1.6666666</td><td>1.8333333</td><td>2</td><td>2.1666666</td><td>2.3333333</td>
				</tr>
				<tr>
					<th>7</th>
					<td>1.4285714</td><td>1.5714285</td><td>1.7142857</td><td>1.8571428</td><td>2</td>
				</tr>
				<tr>
					<th>8</th>
					<td>1.25</td><td>1.375</td><td>1.5</td><td>1.625</td><td>1.75</td>
				</tr>
				<tr>
					<th>9</th>
					<td>1.1111111</td><td>1.2222222</td><td>1.3333333</td><td>1.4444444</td><td>1.5555555</td>
				</tr>
				<tr>
					<th>A</th>
					<td>1</td><td>1.1</td><td>1.2</td><td>1.3</td><td>1.4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>8.4444443^-01</td><td>1</td><td>1.2525252</td><td>1.3434343</td><td>1.4343434</td>
				</tr>
				<tr>
					<th>C</th>
					<td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>1</td><td>1.23</td><td>1.3</td>
				</tr>
				<tr>
					<th>D</th>
					<td>4.^-01</td><td>6.^-01</td><td>8.^-01</td><td>1</td><td>1.2</td>
				</tr>
				<tr>
					<th>E</th>
					<td>5.2929292^-01</td><td>2.2929292^-01</td><td>5.2929292^-0</td><td>8.2929292^-01</td><td>1</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>0.^-01</td><td>1.^-01</td><td>2.^-01</td><td>3.^-01</td><td>4.^-01</td>
				</tr>
				<tr>
					<th>11</th>
					<td>9.090909^-01</td><td>0.^-01</td><td>0.9090909^-01</td><td>1.8181818-01</td><td>2.7272727-01</td>
				</tr>
				<tr>
					<th>12</th>
					<td>8.3333333^-01</td><td>9.1666666^-01</td><td>0.^-01</td><td>0.8333333-01</td><td>1.6666666-01</td>
				</tr>
				<tr>
					<th>13</th>
					<td>7.6923076^-01</td><td>8.4615384^-01</td><td>9.2307692^-01</td><td>0.^-01</td><td>0.7692307-01</td>
				</tr>
				<tr>
					<th>14</th>
					<td>7.1428571^-01</td><td>7.8571428^-01</td><td>8.5714285^-01</td><td>9.2857142-01</td><td>0.^-01</td>
				</tr>
				<tr>
					<th>15</th>
					<td>6.6666666^-01</td><td>7.3333333^-01</td><td>8.^-01</td><td>8.6666666-01</td><td>9.3333333-01</td>
				</tr>
				<tr>
					<th>16</th>
					<td>6.25^-01</td><td>6.875^-01</td><td>7.5^-01</td><td>8.125-01</td><td>8.75-01</td>
				</tr>
				<tr>
					<th>17</th>
					<td>5.8823529^-01</td><td>6.4705882^-01</td><td>7.0588235^-01</td><td>7.6470588-01</td><td>8.2352941-01</td>
				</tr>
				<tr>
					<th>18</th>
					<td>5.5555555^-01</td><td>6.1111111^-01</td><td>6.6666666^-01</td><td>7.2222222-01</td><td>7.7777777-01</td>
				</tr>
				<tr>
					<th>19</th>
					<td>5.2631578^-01</td><td>5.7894736^-01</td><td>6.3157894^-01</td><td>6.8421052-01</td><td>7.368421-01</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>5.^-01</td><td>5.1^-01</td><td>6.3157894-01</td><td>6.1^-01</td><td>7.^-01</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>5.0330001^-01</td><td>6.^-01</td><td>7.0001032-01</td><td>7.8330001-01</td><td>8.2330001-01</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>6.^-01</td><td>7.0003809^-01</td><td>7.8100038-01</td><td>8.1810003-01</td><td>8.100038-01</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>7.0005899^-01</td><td>7.9000589^-01</td><td>8.^-01</td><td>9.0005899-01</td><td>9.9000589-01</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>5.64^-01</td><td>5.90002^-01</td><td>6.4^-01</td><td>6.60002-01</td><td>7.24-01</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>5.4000299^-01</td><td>5.3223099^-01</td><td>6.153223-01</td><td>7.0002999-01</td><td>7.7000299-01</td>
				</tr>
			</table>
			<p>
				Здесь кроме случая X = 1, и некоторых двузначных это обычное
				деление нормализованного шестнадцатеричного числа. Пример:
				E &divide; 7 = 14 &divide; 7 = 2.
				<br>
				Правда и здесь встречаются не нормализованные числа
				(пример D &divide; 12, или C &divide; 11, которое на порядок меньше,
				чем A &divide; 11).
				<br>
				Встречаются и не нормализованные нули, пример:   С &divide; 12, и
				выглядит, как указано:
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-01</span>.
				Впрочем, <a href="#div_indirect_addr">в косвенной адресации</a> мы
				уже встречались с подобными нулями.
			</p>
		</details>

		<details id="div_hex_y_div_h" open>
			<summary><h4>Операция Y <span class="but">&divide;</span> H</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>9.090909^-01</td><td>9.9099099^-01</td><td>4.4444443</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>1</th>
					<td>ЕГГ0Г</td><td>9.099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>2</th>
					<td>ЕГГ0Г</td><td>8.4444443^-01</td><td>9.099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>3</th>
					<td>ЕГГ0Г</td><td>6.4444443^-01</td><td>ЕГГ0Г</td><td>9.099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<th>4</th>
					<td>ЕГГ0Г</td><td>4.4444443^-01</td><td>ЕГГ0Г</td><td>8.^-01</td><td>9.099099^-01</td>
				</tr>
				<tr>
					<th>5</th>
					<td>ЕГГ0Г</td><td>2.4444443^-01</td><td>ЕГГ0Г</td><td>0.^-01</td><td>2.929292^-02</td>
				</tr>
				<tr>
					<th>6</th>
					<td>ЕГГ0Г</td><td>6.4444443^-01</td><td>ЕГГ0Г</td><td>2.^-01</td><td>3.2929292^-01</td>
				</tr>
				<tr>
					<th>7</th>
					<td>ЕГГ0Г</td><td>4.4444443^-01</td><td>ЕГГ0Г</td><td>4.^-01</td><td>6.2929292^-01</td>
				</tr>
				<tr>
					<th>8</th>
					<td>ЕГГ0Г</td><td>2.4444443^-01</td><td>ЕГГ0Г</td><td>0</td><td>9.2929292^-01</td>
				</tr>
				<tr>
					<th>9</th>
					<td>ЕГГ0Г</td><td>0.4444443^-01</td><td>ЕГГ0Г</td><td>2.^-01</td><td>2.2929292^-01</td>
				</tr>
				<tr>
					<th>A</th>
					<td>1</td><td>8.4444443^-01</td><td>ЕГГ0Г</td><td>4.^-01</td><td>5.2929292^-01</td>
				</tr>
				<tr>
					<th>B</th>
					<td>1.1</td><td>1</td><td>ЕГГ0Г</td><td>6.^-01</td><td>2.2929292^-01</td>
				</tr>
				<tr>
					<th>C</th>
					<td>1.2</td><td>1.2525252</td><td>1</td><td>8.^-01</td><td>5.2929292^-01</td>
				</tr>
				<tr>
					<th>D</th>
					<td>1.3</td><td>1.3434343</td><td>1.23</td><td>1</td><td>8.2929292^-01</td>
				</tr>
				<tr>
					<th>E</th>
					<td>1.4</td><td>1.4343434</td><td>1.3</td><td>1.2</td><td>1</td>
				</tr>
				<tr>
					<td colspan=6></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td>ЕГГ0Г</td><td>9.09909</td><td>9.9099099</td><td>9.9099099</td><td>9.9099099</td>
				</tr>
				<tr>
					<th>11</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>9.8</td><td>9.0292929</td>
				</tr>
				<tr>
					<th>12</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0</td><td>9.3292929</td>
				</tr>
				<tr>
					<th>13</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0.2</td><td>9.6292929</td>
				</tr>
				<tr>
					<th>14</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0.4</td><td>9.9292929</td>
				</tr>
				<tr>
					<th>15</th>
					<td>ЕГГ0Г</td><td>9</td><td>ЕГГ0Г</td><td>9</td><td>0.22922929</td>
				</tr>
				<tr>
					<th>16</th>
					<td>ЕГГ0Г</td><td>9.2525252</td><td>ЕГГ0Г</td><td>9.2</td><td>0.5292929</td>
				</tr>
				<tr>
					<th>17</th>
					<td>ЕГГ0Г</td><td>9.3434343</td><td>ЕГГ0Г</td><td>9.4</td><td>9.2292929</td>
				</tr>
				<tr>
					<th>18</th>
					<td>ЕГГ0Г</td><td>9.4343434</td><td>ЕГГ0Г</td><td>9.6</td><td>9.5292929</td>
				</tr>
				<tr>
					<th>19</th>
					<td>ЕГГ0Г</td><td>9.5252525</td><td>ЕГГ0Г</td><td>9.8</td><td>9.8292929</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>ЕГГ0Г</td><td>9.6</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>ЕГГ0Г</td><td>9.8525252</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>ЕГГ0Г</td><td>9.9434343</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>ЕГГ0Г</td><td>0.0343434</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>ЕГГ0Г</td><td>7.4444443</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
			</table>
			<p>
				Тут логики не наблюдается. Очень похожие, но разные числа:
				9.099099^-01 и 9.9099099^-01 (или 9.099099 и 9.9099099).
				Также интересно, что ноль разделить на H вовсе не ноль.
				<br>
				А самое главное, тут не просто ЕГГ0Г, а <strong>плохой ЕГГ0Г</strong>,
				который ранее не встречался. После его появления ПМК в дальнейшем
				(до выключения ПМК) при выполнении многих операций
				всегда выдаёт ЕГГ0Г. Вот список таких операций.
			</p>
			<ul>
				<li><span class="but">+</span></li>
				<li><span class="but">-</span></li>
				<li><span class="but">&times;</span></li>
				<li><span class="but">&divide;</span></li>
				<li><span class="but">&lt;-&gt;</span></li>
				<li><span class="but_f">F</span><span class="op_f">sin</span></li>
				<li><span class="but_f">F</span><span class="op_f">cos</span></li>
				<li><span class="but_f">F</span><span class="op_f">tg</span></li>
				<li><span class="but_f">F</span><span class="op_f">&radic;</span></li>
				<li><span class="but_f">F</span><span class="op_f">1/x</span></li>
				<li><span class="but_f">F</span><span class="op_f">sin⁻¹</span></li>
				<li><span class="but_f">F</span><span class="op_f">cos⁻¹</span></li>
				<li><span class="but_f">F</span><span class="op_f">tg⁻¹</span></li>
				<li><span class="but_f">F</span><span class="op_f">&pi;</span></li>
				<li><span class="but_f">F</span><span class="op_f">x&sup2;</span></li>
				<li><span class="but_f">F</span><span class="op_f">eˣ</span></li>
				<li><span class="but_f">F</span><span class="op_f">lg</span></li>
				<li><span class="but_f">F</span><span class="op_f">ln</span></li>
				<li><span class="but_f">F</span><span class="op_f">xʸ</span></li>
				<li><span class="but_f">F</span><span class="op_f">10ˣ</span></li>
				<li><span class="but_f">F</span><span class="op_f">&orarr;</span></li>
			</ul>
			<p>
				Ошибка возникает как в режиме вычислений, так и в программном
				режиме. Интересно, что
				<span class="but_f">F</span><span class="op_f">&orarr;</span> выдаёт ошибку,
				а <span class="but_f">F</span><span class="op_f">Вx</span> &ndash; нет.
			</p>
			<p>
				"Синии" функции работают нормально. Видимо такой ЕГГ0Г "сводит с ума"
				только один микроконтроллер.
			</p>
		</details>

		<details id="div_hex_func" open>
			<summary><h4>Результат функций над шестнадцатеричными числами</h4></summary>
			<table class="trcenter">
				<tr>
					<td><sub>H</sub>&Backslash;<sup>F(H)</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">&radic;</span></td>
					<td>3.1622776</td><td>3.3166247</td><td>3.4641016</td><td>3.6055512</td><td>3.7416573</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td>ЕГГ0Г</td><td>9.099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td><td>9.9099099^-01</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">eˣ</span></td>
					<td>22026.467</td><td>59874.133</td><td>162754.78</td><td>442413.37</td><td>1202604.3</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td>1.^+10</td><td>1.^+0L</td><td>1.^+0C</td><td>1.^+0Г</td><td>1.^+0E</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">lg</span></td>
					<td>1</td><td>41.823681</td><td>42.40274</td><td>42.816354</td><td>43.126564</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">ln</span></td>
					<td>2.3025851</td><td>96.302585</td><td>97.635918</td><td>98.588299</td><td>99.302585</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&sup1;</span></td>
					<td>10</td><td>6.6631773^+41</td><td>2.5277867^+42</td><td>6.551706^+42</td><td>1.3383338^+43</td>
				</tr>
				<tr>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
			</table>
			<ul>
				<li>
					Результат возведения в квадрат согласуется с таблицей
					умножения, приведенной выше.
				</li>
				<li>
					Излечение корня вообще по правилам &ndash; как корень из
					нормализованного числа.
				</li>
				<li>
					Обратная величина также согласуется с таблицей деления, причем
					здесь опять плохой ЕГГ0Г.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">eˣ</span>
					тоже как корень &ndash; всё по правилам.</li>
				<li>
					<span class="but_f">F</span><span class="op_f">10ˣ</span>
					отображает шестнадцатеричную степень, только цифра A не любит светиться.
				</li>
				<li>Результаты логарифмов уже не понятны.</li>
				<li>
					<span class="but_f">F</span><span class="op_f">x&sup1;</span>
					это <span class="but_f">F</span><span class="op_f">xʸ</span>,
					для случая Y = 1. Впрочем результат от этого не становится более ясным.
					Кроме числа A, остальные возводятся в первую степень как какие-то
					суперчисла.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span> похож на
					сложение с нулем. Причем, если бы число было ещё с дробной частью,
					то целая часть осталась бы без изменений, даже шестнадцатеричная.
				</li>
			</ul>
			<p>
				Про более редкие операции переводов градусов/часов сказано
				<a href="#div_command">в приложении по командам</a>.
				Числа, где порядок содержит шестнадцатеричные значения, рассмотрены
				в разделе косвенной адресации
				<a href="#div_indirect_addr_exponent">
					Порядок содержит шестнадцатеричные цифры
				</a>.
			</p>
		</details>

		<details id="div_hex_using" open>
			<summary><h4>Практическое применение</h4></summary>
			Практическое применение &ndash; это получение нестандартного
			результата (как отличие от обычной цифры). Или получение нестандартной
			последовательности. Или как был приведен выше по умножению.
			<p>
				Случаи с двойными и более шестнадцатеричными числами (в том числе в
				дробной части) не рассмотрены, как очень редко встречающиеся.
				Там тоже можно построить подобные таблицы, но проще посмотреть
				результат под конкретное число.
			</p>
		</details>
	</details>

	<hr>

	<details id="div_zero_digit" open>
		<summary><h3>Числа, у которых вместо знака стоит цифра</h3></summary>
		Рассматривается работа с числами, у которых вместо знака стоит цифра.
		В дальнейшем будем её называть знакоцифра.
		Автору известны только способы получения чисел, где знакоцифра получается
		из диапазона 2&hellip;9. Более того, есть основание думать, что кроме них
		допустимы только ещё только две цифры: A = минус, представляет
		отрицательные числа, и 1, которая отображается
		как пустое место и представляет положительные числа.
		Для ПМК БЗ-34 было возможно отображение и других цифр, но в МК-61 это не работает.
		<p>
			Напомню, что знакоцифра успешно "выживает" при косвенной адресации.
			Обратите внимание, что далее в этом разделе очень часто в примерах у чисел
			вначале указывается именно знакоцифра.
		</p>

		<details id="div_zero_digit_get" open>
			<summary><h4>Способы получения</h4></summary>
			<ol>
				<li>
					<strong>Хвосты 0C-оборотней</strong>. В этом случае используются знания
					Еггогологии. 0С-оборотни &ndash; это числа в диапазоне
					1.^400&hellip;9.9999999^499.
					Для получения таких чисел (точнее "хвостов") воспользуемся программой:
					<p>
						<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="code_num">01.</span><span class="but">5</span>&ensp;
						<span class="code_num">02.</span><span class="but">0</span>&ensp;
						<span class="code_num">03.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
						<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="code_num">05.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="code_num">07.</span><span class="but">&times;</span>&ensp;
						<span class="code_num">08.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
						<span class="code_num">09.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
						<span class="code_num">10.</span><span class="but_b">П&rarr;x</span><span class="reg">c</span>&ensp;
						<span class="code_num">11.</span><span class="but">ВП</span>&ensp;
						<span class="code_num">12.</span><span class="but">7</span>&ensp;
						<span class="code_num">13.</span><span class="but_b">С/П</span>
					</p>
					<p>
						На вход ей передатся число (0&hellip;8.9999999], на выходе получаем
						"хвост" оборотня из регистра Rc. Поэтому их
						и называют 0C-оборотни, что сами они на экран дают ноль, а "хвост"
						сбрасывают в регистр Rc. Передавать на вход
						девятку неинтересно, т.к. на выходе получим 10, точнее цифру А,
						т.е. обычный минус.
						<br>
						Пример, передав 1, получим
						<span class="code">2E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
						передав 6, получим
						<span class="code">7E.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>,
						и т.д. Нажав <span class="but">/-/</span> получим другую знакоцифру
						(вычислить какую именно легко, т.к. сумма таких парных знакоцифр = 11).
						Кстати, если мантисса нулевая, то после <span class="but">/-/</span>
						будет -0 для любой знакоцифры.
					</p>
					<p>
						Этот способ получения знакоцифры не очень удобен, тем более, что
						для получения других цифр мантиссы нужно сильно "напрячься",
						например многократно прокрутив счётчик косвенной адресации.
						Есть способ лучше.
					</p>
				</li>
				<li>
					<strong>Использование косвенной адресации регистров R4&hellip;R6</strong>.
					О том, что при использовании шестнадцатеричных чисел в косвенной
					адресации для R4&hellip;R6 идёт их "нормализация" уже было
					упомянуто в <a href="#div_indirect_addr_mantissa">
						Мантисса содержит шестнадцатеричные цифры
					</a>.
					<p>
						Так вот, если первая цифра 8-значного числа тоже шестнадцатеричная, то
						перенос из старшего разряда происходит в знаковый разряд, т.е.
						появляется знакоцифра.
					</p>
					<p>
						Для начала возьмем обычную цифру E (для краткости
						нестандартным способом), которая потом пригодится:
						<span class="but">1</span>&ensp;
						<span class="but_k">К</span><span class="but">-</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="reg">e</span>.
						Затем сделаем её первой (число 8-значным):
						<span class="but">ВП</span>&ensp;
						<span class="but">7</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="but">4</span>.
						Получили <span class="code">&nbsp;E0000000.&nbsp;&nbsp;&nbsp;</span>.
						Если теперь использовать косвенное увеличение:
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>,
						то получим <span class="code">240000001.&nbsp;&nbsp;&nbsp;</span>.
						Тут из цифры E сделан перенос единицы в знаковый разряд.
						В отличии от 0С-оборотней мы пока получили только знакоцифру два
						(или 9, если нажать <span class="but">/-/</span>), зато остальные
						цифры мантиссы легко выбрать нужные (кроме шестнадцатеричных,
						которые косвенной адресацией нормализуются), а с помощью
						<a href="#div_x2_exp_combine">
							восстановление X2 с заменой первой цифры на цифру из числа в X
						</a>
						можно и первую цифру сделать шестнадцатеричной.
						Введем простую программу:
					</p>
					<p>
						<span class="code_num">00.</span><span class="but">&lt;-&gt;</span>&ensp;
						<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
						<span class="code_num">02.</span><span class="but">ВП</span>&ensp;
						<span class="code_num">03.</span><span class="but_b">С/П</span>
					</p>
					<p>
						Эта программа меняет у числа в X первую цифру на первую
						цифру из числа в Y.
						Соответственно, возьмем цифру E и наше новое число со знакоцифрой два
						и объединим их:
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">В/О</span>&ensp;
						<span class="but_b">С/П</span>.
						Получили
						<span class="code">2E0000001.&nbsp;&nbsp;&nbsp;</span>.
						Если такое число провести через косвенную адресацию:
						<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>,
						то получим <span class="code">340000002.&nbsp;&nbsp;&nbsp;</span>.
						Таким же образом можно получить остальные знакоцифры
						(до 9 включительно). Кому эстетически не нравиться хвостик
						(в данном случае 2), его можно сбросить до нуля, уже через
						косвенную адресацию с использованием R0&hellip;R3.
					</p>
				</li>
			</ol>
		</details>

		<details id="div_zero_digit_sign" open>
			<summary><h4>Какой знак у числа?</h4></summary>
			Первый вопрос, который приходит на ум, глядя на такие числа, а они
			положительные или отрицательные? В дальнейшем для обозначения
			будем использовать <strong>2</strong>N, <strong>3</strong>N,
			&hellip; <strong>9</strong>N, где знакоцифра
			указана явно, а мантисса (может + порядок) обозначена буквой N.
			<table class="trcenter">
				<tr>
					<td></td>
					<td><strong>2</strong>N</td>
					<td><strong>3</strong>N</td>
					<td><strong>4</strong>N</td>
					<td><strong>5</strong>N</td>
					<td><strong>6</strong>N</td>
					<td><strong>7</strong>N</td>
					<td><strong>8</strong>N</td>
					<td><strong>9</strong>N</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
					<td>Нет</td><td>Нет</td><td>Нет</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Нет</td><td>Нет</td><td>Нет</td>
				</tr>
			</table>
			<p>
				Как видно, далеко не всё так прозрачно. <strong>5</strong>N и
				<strong>6</strong>N	получаются и отрицательные и положительные.
				Сравнения с нулем, кстати, для всех проходят корректно (не ноль, если
				N не ноль).
				<br>
				Рассмотрим другие функции, для косвенного определения знака числа.
			</p>
			<ul>
				<li>
					<span class="but_f">F</span><span class="op_f">10ˣ</span>
					выдаёт положительный порядок только для <strong>9</strong>N.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">1/x</span>
					наоборот считает <strong>9</strong>N отрицательным, а остальные положительными.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">eˣ</span>
					тоже только <strong>9</strong>N считает отрицательным.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">&radic;</span>
					все считает отрицательными, т.е. даёт ошибку.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">lg</span> и
					<span class="but_f">F</span><span class="op_f">ln</span>
					все считает отрицательными, т.е. дают ошибку.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">sin</span>
					все считает отрицательными, т.е. результат отрицательный.
					Остальные тригонометрический функции ведут себя аналогично.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
					или
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
					считают их отрицательными, а
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>
					и <span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					не меняют знакоцифру.
				</li>
				<li>
					Парадоксально, но функция
					<span class="but_f">F</span><span class="op_f">x&sup2;</span>
					для чисел <strong>5</strong>N&hellip;<strong>8</strong>N
					результат делает отрицательным,	хоть и правильным по модулю.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">xʸ</span>
					все считает отрицательными, если числа являются основанием
					(т.е. даёт ошибку), но в качестве показателя различает,
					считая <strong>9</strong>N отрицательным, а остальные положительными.
				</li>
			</ul>
		</details>

		<details id="div_zero_digit_eval" open>
			<summary><h4>Арифметика с этими числами</h4></summary>
			Нужно понимать, что "по модулю" функции считают правильно, обычно только
			знак результата бывает не очевиден.
			Часть функций уже была рассмотрена выше, где мы пытались определить знак числа.
			Рассмотрим другие:
			<ul>
				<li>
					<span class="but_k">К</span><span class="op_k">ЗН</span> заменяет
					мантиссу на 1, оставляя знакоцифру, т.е. от <strong>8</strong>N,
					получится <strong>8</strong>1.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&mid;x&mid;</span>
					отбрасывает знакоцифру, как и ожидалось.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span>
					оставляет целую часть и ставит знак минус.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">{x}</span>,
					оставляет дробную часть вместе со знакоцифрой, если
					число по модулю &lt; 1<sup>7</sup> (точнее число, которому нужно
					меньше восьми знакомест). Для больших чисел знакоцифра удаляется.
				</li>
				<li>
					<span class="but">+</span> в любом сочетании считает их отрицательными.
				</li>
				<li>
					<span class="but">-</span> ведёт себя хитрее. Когда число со знакоцифрой
					уменьшаемое, т.е. находится в регистре Y, то ведёт себя как
					отрицательное, но когда вычитаемое (находится в регистре X), то
					наоборот, как положительное. Например, возьмем <strong>6</strong>3
					(6 &ndash; знакоцифра),
					тогда <strong>6</strong>3 &minus; 1 = -4,
					а вот 1 &minus; <strong>6</strong>3 = -2.
					Отсюда следует, что вычитание двух чисел со знакоцифрами
					складывает их модули, но результат оставляет отрицательным,
					т.е. ведёт себя в точности, как сложение(!).
				</li>
				<li>
					<span class="but">&times;</span>, <span class="but">&divide;</span>
					обрабатываются сложнее, нужна таблица (порядок операндов не важен):
					<table class="trcenter">
						<tr>
							<td></td>
							<td><strong>+</strong>N</td>
							<td><strong>2</strong>N</td>
							<td><strong>3</strong>N</td>
							<td><strong>4</strong>N</td>
							<td><strong>5</strong>N</td>
							<td><strong>6</strong>N</td>
							<td><strong>7</strong>N</td>
							<td><strong>8</strong>N</td>
							<td><strong>9</strong>N</td>
							<td><strong>-</strong>N</td>
						</tr>
						<tr>
							<td><strong>+</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>2</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>3</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>4</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>5</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>6</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>7</strong>N</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><strong>8</strong>N</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
						</tr>
						<tr>
							<td><strong>9</strong>N</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
							<td>+</td>
						</tr>
						<tr>
							<td><strong>-</strong>N</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
						</tr>
					</table>
					Результат, по крайней мере, согласуется с поведением функций
					<span class="but_f">F</span><span class="op_f">1/x</span> и
					<span class="but_f">F</span><span class="op_f">x&sup2;</span>
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">max</span> считает
					числа с разными знакоцифрами равными (если N одинаковый),
					например для <strong>8</strong>N и <strong>2</strong>N операция
					не будет делать ничего
					(кроме сброса X в X1), к каком бы порядке они не стояли.
					<br>Но при этом все они меньше, чем <strong>+</strong>N, и больше,
					чем <strong>-</strong>N.
				</li>
			</ul>
			<p>
				Тут нужно остановиться на нуле. Как указано в функции
				<span class="but_k">К</span><span class="op_k">{x}</span>, может
				получится ноль со знакоцифрой. Так вот, он ведёт себя как обычный ноль.
				Единственное отличие &ndash; это в функциях сравнения. Такой ноль ведёт
				себя так, как указано ранее для чисел со знакоцифрой. В частности число
				<span class="code">50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
				операторы
				<span class="but_f">F</span><span class="op_f">x&lt;0</span>,
				<span class="but_f">F</span><span class="op_f">x&ge;0</span>,
				<span class="but_f">F</span><span class="op_f">x=0</span>
				пропустят, как удовлетворяющее условию.
			</p>
		</details>

		<details id="div_zero_digit_sum" open>
			<summary><h4>Произвольная мантисса и выводы</h4></summary>
			Как видно, почти все операции уничтожают знакоцифру. Гарантированная
			доступная возможность менять мантиссу без изменения знакоцифры &ndash;
			это использовать косвенную адресацию. И конечно мантиссу можно заранее
			подготовить. Пример (использую программу и цифру E, полученную выше):
			<p>
				<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">В/О</span>&ensp;
				<span class="but_b">С/П</span>
				Получили
				<span class="code">&nbsp;E9999998.&nbsp;&nbsp;&nbsp;</span>.
				Затем
				<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but_b">В/О</span>&ensp;
				<span class="but_b">С/П</span>.
				Получим <span class="code">299999999.&nbsp;&nbsp;&nbsp;</span>
				(Кстати, если нажать <span class="but">/-/</span>, то получим девять
				девяток). Теперь снова сделаем над ним операцию
				<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>.
				Мы увидим довольно симпатичный не нормализованный ноль
				<span class="code">300000000.&nbsp;&nbsp;&nbsp;</span>, которому
				можно поставить любую первую цифру (но не знакоцифру), как сделано
				только что по программе. Кстати, если бы
				мы так сделали с девятью девятками, то получили бы
				<span class="code">-00000000.&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Фактически, таким образом можно получать почти любые мантиссы
				(кроме шестнадцатеричных) с нужной знакоцифрой.
			</p>
			<p>
				Например, хотим получить <strong>3</strong>21, где 3 &ndash; знакоцифра.
				Используя короткую программу, указанную в начале раздела, у числа
				<span class="code">&nbsp;10000019.&nbsp;&nbsp;&nbsp;</span>, заменим
				первую цифру на E, получим
				<span class="code">&nbsp;E0000019.&nbsp;&nbsp;&nbsp;</span>.
				После косвенного увеличения станет
				<span class="code">240000020.&nbsp;&nbsp;&nbsp;</span>. Снова заменим
				на E, получим
				<span class="code">2E0000020.&nbsp;&nbsp;&nbsp;</span>. Повторное
				косвенное увеличение приведёт к
				<span class="code">340000021.&nbsp;&nbsp;&nbsp;</span>. Теперь,
				после замены первой цифры на ноль, останется
				<span class="code">321.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Ещё пример. Хочу получить <big>&pi;</big>/2 (для работы с
				тригонометрическими функциями), и знакоцифру девять.
				<big>&pi;</big>/2 = 1.5707963.
				Начнем с
				<span class="code">&nbsp;15707962.&nbsp;&nbsp;&nbsp;</span>, заменим
				первую цифру на E, получим
				<span class="code">&nbsp;E5707962.&nbsp;&nbsp;&nbsp;</span>.
				После косвенного увеличения станет
				<span class="code">245707963.&nbsp;&nbsp;&nbsp;</span>. Нажмем
				<span class="but">/-/</span>, получим
				<span class="code">945707963.&nbsp;&nbsp;&nbsp;</span> и сделаем
				замену первой цифра на 1:
				<span class="code">915707963.&nbsp;&nbsp;&nbsp;</span>. Осталось
				только
				<span class="but">ВП</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">1</span>,
				и мы получили, что хотели
				<span class="code">91.5707963&nbsp;&nbsp;&nbsp;</span>.
				Можно проверить тригонометрические функции
				на нем, например синус о него даёт -1.
			</p>
			<p>
				На самом деле можно получить числа со знакоцифрам и шестнадцатеричными
				цифрами в мантиссе. Сначала получим, как указано в начале
				<span class="code">240000001.&nbsp;&nbsp;&nbsp;</span>, а затем
				применим следующий алгоритм:
			</p>
			<ol>
				<li>Ставим первой шестнадцатеричную цифру (E из Re) по минипрограмме.</li>
				<li>Если все цифры мантиссы уже шестнадцатеричные, то завершаем.</li>
				<li>
					Уменьшаем с помощью
					<span class="but">ВП</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but">/-/</span> порядок на единицу.
				</li>
				<li>
					У полученного значения через косвенную адресацию в R7&hellip;Rd убираем
					дробную часть. При этом вместо первой цифры будет вписано
					знакоцифра &minus; 1, а наша шестнадцатеричная цифра отодвинется.
					Переходим на п.1.
				</li>
			</ol>
			<p>
				По такому алгоритму и цифре E легко получается
				<span class="code">2EEEEEEEE.&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Понятно, что в пункте 1 алгоритма можно вписать любую цифру
				(кроме E). И начать с числа с любой знакоцифрой. Таким образом можно
				получить практически любую мантиссу с
				любой знакоцифрой (кроме цифр F или ведущих нулей).
			</p>
			<p>
				Более того, такие знакоцифры влияют и на остальное. Возьмем, для примера
				<a href="#div_x2_exp_SR">
					Восстановление X2 с отбрасыванием первой цифры
				</a>. На самом деле указанная там последовательность при восстановлении
				вместо первой цифры записывает знакоцифру &minus; 1, что для положительного
				числа равно нулю, т.е. отбрасывание цифры. А вот если знакоцифра есть,
				то эта последовательность запишет её минус один вместо первого знака.
				Отсюда же понятно, почему для отрицательных запишет 9, это знак минус,
				как цифра A (= 10) минус один. Причем знакоцифра останется на месте.
			</p>
			<p>
				На <strong>практике</strong> автор не использовал такие числа просто
				в силу того,
				что в момент активного использования ПМК не обладал этими знаниями.
				И хотя нестандартность поведения многих функций с такими числами
				определяется только реакцией на знак числа, всё равно можно
				предположить, что и это можно использовать для оптимизации.
			</p>
		</details>
	</details>

	<hr>

	<details id="div_neg_zero_degree" open>
		<summary><h3>Числа с отрицательной нулевой степенью</h3></summary>
		Из раздела по косвенной адресации мы знаем о правиле "сумма = 160" для
		отрицательных степеней, которые содержат шестнадцатеричные цифры. Есть
		интересный эффект, когда порядок доводится до -160 и в результате
		сложения по правилу получается не нулевая степень, а минус нулевая.
		Оказывается числа с такой степенью тоже имеют необычные свойства.

		<details id="div_nzd_get" open>
			<summary><h4>Способ получения</h4></summary>
			Как можно получить число в такой степенью? Для начала получим число
			с отрицательной степенью, содержащей шестнадцатеричные цифры. Например
			1^.-E0
			(<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-E0</span>):
			<span class="but">1</span>&ensp;
			<span class="but">0</span>&ensp;
			<span class="but">/-/</span>&ensp;
			<span class="but_k">К</span><span class="but">-</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but_f">F</span><span class="op_f">10ˣ</span>.
			Получилось число как 1.^-140 или по правилу 160 = 1.^20. Теперь
			если убрать ещё 20 из порядка:
			<span class="but">ВП</span>&ensp;
			<span class="but">2</span>&ensp;
			<span class="but">0</span>&ensp;
			<span class="but">/-/</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">1</span>.
			то мы получим 1.^-00
			(<span class="code">&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-00</span>).
			<p>
				Если вы думаете, что мантисса может быть только единица, то обрадую, что
				можно и другие. Для исследования чисел с разными мантиссами приведем
				программу, которая регистры R1&hellip;Re заполняет числами с нулевой
				отрицательной степенью, а на месте первой цифры будет стоять номер
				регистра (да, да, для последнего это будет E.^-00).
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">3</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">8</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but">ВП</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">1</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but_f">F</span><span class="op_f">L0</span></td>
					<td><span class="but">18</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_b">С/П</span></td>
					<td colspan=9></td>
				</tr>
			</table>
			<p>
				Тут тоже используются недокументированные возможности. Большую часть
				(адреса с 00 по 17) это получение (документированное) той же 1^.-00, что
				мы сделали руками, только  без ЕГГ0Га. Причем не через E0, а через L0
				(просто число 13 нужно для  цикла по оставшимся регистрам R2&hellip;Re).
				Из-за особенностей поведения <span class="but">ВП</span> в программном
				режиме X нужно копировать в X2. Первый раз нам помогает
				<span class="but">/-/</span> по адресу 08, второй раз уже явно делаем
				<span class="but">В&uarr;</span> по адресу 12. А вот с 18 адреса начинается
				"шаманство". Фрагмент программы 18&hellip;21 увеличивает текущую цифру
				(в шестнадцатеричном смысле). Эта особенность была рассказана в разделе
				про регистр X2 и команду <span class="but">ВП</span>. А фрагмент
				22&hellip;25 (тот же раздел) подставляет эту цифру в число из R1.
				Потом с помощью регистра Re мы сохраняем это в нужном месте и повторяем.
			</p>
			<p>
				Обозначим такое число с необычной степенью как N. В общем случае,
				нулевая степень (пусть с минусом) в математическом смысле ничего не меняет,
				т.е. число должно быть как бы без степени. И большинство операций так
				его и воспринимаю, но есть исключения. Пройдемся по всем
				операциям/функциям, использую значения регистров, внесенные программой выше.
			</p>
		</details>

		<details id="div_nzd_plus" open>
			<summary><h4>Сложение и вычитание</h4></summary>
			Тут порядок операндов неважен. Правило такое: если целая
			часть второго операнда состоит только из одной цифры (сюда же попадают
			шестнадцатеричные цифры и дробная часть может быть любая), то этот
			операнд (т.е. всё число) сначала умножается на 10 (то же и для
			шестнадцатеричных чисел), а затем   выполняется операция с N. Примеры:
			<br>
			2.^-00 + 5.1 = 53:
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">5</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but">+</span> =
			<span class="code">&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			<br>
			2.1 &minus; 3.^-00 = 18:
			<span class="but">2</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
			<span class="but">-</span> =
			<span class="code">&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			<br>
			<big>&pi;</big> &minus; 3.^-00 = 28.415926;
			<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
			<span class="but">-</span> =
			<span class="code">&nbsp;28.415926&nbsp;&nbsp;&nbsp;</span>.
			<br>
			E.1 + 2^.-00 = 43:
			<span class="but">1</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but_k">К</span><span class="but">-</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">+</span> =
			<span class="code">&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			<p>
				Для двух и более значных операндов, выполняется как обычно. Примеры:
				<br>
				2.^-00 + 51 = 53:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				21 &minus; 3.^-00 = 18:
				<span class="but">2</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				e<sup>&pi;</sup> &minus; 3.^-00 = 20.14069:
				<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="but_f">F</span><span class="op_f">eˣ</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">&nbsp;20.14069&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				E1 + 2^.-00 = 43:
				<span class="but">1</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Если дробное число (целая часть нулевая), то выполняется как обычно.
				Примеры:
				<br>
				0.5 + 4.^-00 = 4.5:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;4.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				E.1^-01 + 4.^-00 = 5.41:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;5.41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Сами с собой числа N правила умножения на 10 не придерживаются и выполняются
				как обычно.
				<br>
				5^.-00 + 2.^-00 = 7:
				<span class="but_b">П&rarr;x</span><span class="but">5</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				2^.-00 &minus; 3.^-00 = -1:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">-1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			</p>
			<p>
				Так же как обычно работает, если второй операнд нулевой.
				<br>
				9.^-00 + 0 = 9:
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				Для сравнения:
				<br>
				9.^-00 + 1 = 9:
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code">&nbsp;19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			</p>
		</details>

		<details id="div_nzd_mult" open>
			<summary><h4>Умножение и деление</h4></summary>
			При <strong>умножении</strong>, когда число N перед операцией
			находится в регистре
			Y, а число в регистре X меньше единицы (в абсолютном значении), то
			получается число со степенью -160, т.е. само число N в операции
			воспринимается как число в степени -160 (кстати, с учетом цикличности
			ПМК на 1000 степени можно считать это числом в 840 степени).
			В остальных случаях ведёт как обычное умножение. Пример:
			<br>
			1.5 &times; 2^.-00 = 3:
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">5</span>&ensp;
			<span class="but">&times;</span> =
			<span class="code">&nbsp;3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			<br>
			0.7 &times; 2^.-00 = 1.4^-160:
			<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="but">0</span>&ensp;
			<span class="but">.</span>&ensp;
			<span class="but">7</span>&ensp;
			<span class="but">&times;</span> =
			<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			Вроде бы ноль, но это потому, что при нормализации числа в степени такого
			порядка преобразуются в ноль. Для проверки составим программу, которая
			полученное число умножит на 1^.80:
			<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
			<span class="code_num">02.</span><span class="but">0</span>&ensp;
			<span class="code_num">03.</span><span class="but">.</span>&ensp;
			<span class="code_num">04.</span><span class="but">7</span>&ensp;
			<span class="code_num">05.</span><span class="but">&times;</span>&ensp;
			<span class="code_num">06.</span><span class="but">8</span>&ensp;
			<span class="code_num">07.</span><span class="but">0</span>&ensp;
			<span class="code_num">08.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
			<span class="code_num">09.</span><span class="but">&times;</span>&ensp;
			<span class="code_num">10.</span><span class="but_b">С/П</span>
			<br>
			После <span class="but_b">В/0</span>&ensp;
			<span class="but_b">С/П</span> на экране будет
			<span class="code">&nbsp;1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-80</span>
			<p>
				Если число в X больше единицы, но имеет порядок не меньше 60, то число
				N снова воспринимается, как число в степени -160.
				<br>
				1.^62 &times; 7^.-00 = 7.^-98:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">6</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-98</span>.
				<br>
				1.^60 &times; 7^.-00 = 7.^-100:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">6</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				-1.^99 &times; 7^.-00 = -7.^-61:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">-7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-61</span>.
			</p>
			<p>
				Если число в X меньше единицы, но имеет порядок меньше -40, то
				умножение снова проводится как обычно:
				<br>
				1.^-43 &times; 6^.-00 = 6.^-43:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-43</span>.
				<br>
				1.^-40 &times; 6^.-00 = 6.^-200:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				-1.^-99 &times; 6^.-00 = -6.^-99:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">-6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-99</span>.
			</p>
			<p>
				Напомню, если число N находится в регистре X, то происходит обычное
				умножение, но если в Y тоже N (может другое),
				то будет как выше степень -160.
				<br>
				3^.-00 &times; 7^.-00 = 2.1^-159:
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				Для проверки
				<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="code_num">02.</span><span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="code_num">03.</span><span class="but">&times;</span>&ensp;
				<span class="code_num">04.</span><span class="but">8</span>&ensp;
				<span class="code_num">05.</span><span class="but">0</span>&ensp;
				<span class="code_num">06.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<span class="code_num">07.</span><span class="but">&times;</span>&ensp;
				<span class="code_num">08.</span><span class="but_b">С/П</span> =
				<span class="code">&nbsp;2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-79</span>.
			</p>
			<p>
				Для <strong>деления</strong> ситуация похожая. Необычность возникает,
				только когда
				делят на N (N в регистре X). Если число в регистре Y по модулю в
				диапазоне 1 &les; Y &lt; 10 (сюда же попадают шестнадцатеричные цифры),
				то в операциях деления N выглядит как число со степенью -160.
				<br>
				8^.-00 &divide; 2 = 4:
				<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				18 &divide; 2^.-00 = 9:
				<span class="but">1</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				0.8 &divide; 2^.-00 = 0.4:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-01</span>.
				<br>
				8 &divide; 2^.-00 = 4^.160:
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;ЕГГ0Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				<br>
				Для проверки составим программу:
				<small>00.</small><span class="but_cx">Сx</span>&ensp;
				<small>01.</small><span class="but">8</span>&ensp;
				<small>02.</small><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<small>03.</small><span class="but">&divide;</span>&ensp;
				<small>04.</small><span class="but">7</span>&ensp;
				<small>05.</small><span class="but">0</span>&ensp;
				<small>06.</small><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
				<small>07.</small><span class="but">&divide;</span>&ensp;
				<small>08.</small><span class="but_b">С/П</span>
				<br>
				После <span class="but_b">В/0</span>&ensp;
				<span class="but_b">С/П</span> на экране будет
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90</span>.
			</p>
			<p>
				Единственное исключение &ndash; это когда в Y тоже число N. Тогда
				деление снова проходит как обычно.
				<br>
				8^.-00 &divide; 2^.-00 = 4:
				<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code">&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
			</p>
		</details>

		<details id="div_nzd_func_F" open>
			<summary><h4>"Жёлтые" функции</h4></summary>
			"Жёлтые" функции &ndash; те, которые вызываются через кнопку
			<span class="but_f">F</span>.
			<ul>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">&radic;</span>.
						При взятии корня вычисляется как обычно, но результат делится на
						10<sup>48</sup>, т.е. степень числа будет -48. Пример:
						<br>
						&radic;(4.^-00) = 2.^-48:
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_f">F</span><span class="op_f">&radic;</span> =
						<span class="code">&nbsp;2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-48</span>.
						<br>
						&radic;(E.^-00) = 3.7416573^-48:
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_f">F</span><span class="op_f">&radic;</span> =
						<span class="code">&nbsp;3.7416573-48</span>.
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">1/x</span>.
						Обратная величина считает число N числом  в степени -160.
						<br>
						1 &frasl; (2^.-00) = 5.^159:
						<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_f">F</span><span class="op_f">1/x</span> =
						<span class="code">&nbsp;ЕГГ0Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
						<br>
						Для проверки составим программу:
						<span class="code_num">00.</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="code_num">01.</span><span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
						<span class="code_num">02.</span><span class="but">7</span>&ensp;
						<span class="code_num">03.</span><span class="but">0</span>&ensp;
						<span class="code_num">04.</span><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
						<span class="code_num">05.</span><span class="but">&divide;</span>&ensp;
						<span class="code_num">06.</span><span class="but_b">С/П</span>
						<br>
						После <span class="but_b">В/0</span>&ensp;
						<span class="but_b">С/П</span> на экране будет
						<span class="code">&nbsp;5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;89</span>.
					</p>
				</li>
				<li>
					<p>
						Тригонометрические функции рассмотрим только на нескольких значениях.
					</p>
					<p>
						Для <span class="but_f">F</span><span class="op_f">sin</span> только
						в радианах будут отличия:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>8.4147098^-01</td>
							<td>1.5707317^-02</td>
							<td>1.7452405^-02</td>
						</tr>
						<tr>
							<th>1</th>
							<td>8.4147103^-01</td>
							<td>1.5707317^-02</td>
							<td>1.7452405^-02</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">cos</span> тоже:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>2.^-00</th>
							<td>4.4721363^-01</td>
							<td>9.9950656^-01</td>
							<td>9.9939082^-01</td>
						</tr>
						<tr>
							<th>2</th>
							<td>-4.1614688^-01</td>
							<td>9.9950656^-01</td>
							<td>9.9939082^-01</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">tg</span> тоже:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>3.^-00</th>
							<td>3</td>
							<td>4.7158802^-02</td>
							<td>5.2407778^-02</td>
						</tr>
						<tr>
							<th>3</th>
							<td>-1.4254648^-01</td>
							<td>4.7158802^-02</td>
							<td>5.2407778^-02</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">sin⁻¹</span>
						все отличаются:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>7.853981^-01</td>
							<td>50.000003</td>
							<td>45.000002</td>
						</tr>
						<tr>
							<th>1</th>
							<td>1.5707963</td>
							<td>100</td>
							<td>90</td>
						</tr>
						<tr>
							<th>2.^-00</th>
							<td>1.1071486</td>
							<td>70.483276</td>
							<td>63.434949</td>
						</tr>
						<tr>
							<th>2</th>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">cos⁻¹</span>
						все отличаются:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>7.8539812^-01</td>
							<td>49.999997</td>
							<td>44.999998</td>
						</tr>
						<tr>
							<th>1</th>
							<td>0</td>
							<td>00</td>
							<td>00</td>
						</tr>
						<tr>
							<th>2.^-00</th>
							<td>4.6364761^-01</td>
							<td>29.516724</td>
							<td>26.565051</td>
						</tr>
						<tr>
							<th>2</th>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">tg⁻¹</span>
						для чисел N всегда даёт ноль:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.^-00</th>
							<td>0</td>
							<td>0</td>
							<td>00</td>
						</tr>
						<tr>
							<th>1</th>
							<td>7.853981^-01</td>
							<td>50.000003</td>
							<td>45.000002</td>
						</tr>
						<tr>
							<td colspan=4></td>
						</tr>
						<tr>
							<th>8.^-00</th>
							<td>0</td>
							<td>0</td>
							<td>00</td>
						</tr>
						<tr>
							<th>8</th>
							<td>1.4464413</td>
							<td>92.083315</td>
							<td>82.874983</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>
						вычисляет как обычно, но порядок числа при этом уменьшается на 160.
						При нормализации получается ноль:
						<br>
						2^.00&sup2; = 4^.-160:
						<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>
						даёт <span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
						<br>
						8^.00&sup2; = 6.4^-159:
						<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>
						даёт <span class="code">&nbsp;0.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
						<br>
						Но небольшая проверка показывает истинную картину:
						<small>00.</small><span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
						<small>01.</small><span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<small>02.</small><span class="but">7</span>&ensp;
						<small>03.</small><span class="but">0</span>&ensp;
						<small>04.</small><span class="but_f">F</span><span class="op_f">10ˣ</span>&ensp;
						<small>05.</small><span class="but">&times;</span>&ensp;
						<small>06.</small><span class="but_b">С/П</span>
						<br>
						После <span class="but_b">В/0</span>&ensp;
						<span class="but_b">С/П</span> на экране будет
						<span class="code">&nbsp;6.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-89</span>.
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">eˣ</span>
						вычисляется как обычно.
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">lg</span>
						выдаёт так:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">lg</span></td>
						</tr>
						<tr>
							<th>1^.-00</th>
							<td>0</td>
						</tr>
						<tr>
							<th>2^.-00</th>
							<td>-43.128418</td>
						</tr>
						<tr>
							<th>3^.-00</th>
							<td>-42.952326</td>
						</tr>
						<tr>
							<th>4^.-00</th>
							<td>-42.827388</td>
						</tr>
						<tr>
							<th>5^.-00</th>
							<td>-42.730478</td>
						</tr>
						<tr>
							<th>6^.-00</th>
							<td>-42.651297</td>
						</tr>
						<tr>
							<th>7^.-00</th>
							<td>-42.58435</td>
						</tr>
						<tr>
							<th>8^.-00</th>
							<td>-42.526358</td>
						</tr>
						<tr>
							<th>9^.-00</th>
							<td>-42.475205</td>
						</tr>
						<tr>
							<th>A^.-00</th>
							<td>-42.429448</td>
						</tr>
						<tr>
							<th>B^.-00</th>
							<td>-1.6057671</td>
						</tr>
						<tr>
							<th>C^.-00</th>
							<td>-1.0267076</td>
						</tr>
						<tr>
							<th>D^.-00</th>
							<td>-6.1309386^-01</td>
						</tr>
						<tr>
							<th>E^.-00</th>
							<td>-3.0288357^-01</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">ln</span>
						тоже начиная с B.^-00 выдаёт другой порядок:
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">ln</span></td>
						</tr>
						<tr>
							<th>1^.-00</th>
							<td>0</td>
						</tr>
						<tr>
							<th>2^.-00</th>
							<td>-99.306853</td>
						</tr>
						<tr>
							<th>3^.-00</th>
							<td>-98.901388</td>
						</tr>
						<tr>
							<th>4^.-00</th>
							<td>-98.613706</td>
						</tr>
						<tr>
							<th>5^.-00</th>
							<td>-98.390562</td>
						</tr>
						<tr>
							<th>6^.-00</th>
							<td>-98.208241</td>
						</tr>
						<tr>
							<th>7^.-00</th>
							<td>-98.05409</td>
						</tr>
						<tr>
							<th>8^.-00</th>
							<td>-97.920559</td>
						</tr>
						<tr>
							<th>9^.-00</th>
							<td>-97.802776</td>
						</tr>
						<tr>
							<th>A^.-00</th>
							<td>-97.697415</td>
						</tr>
						<tr>
							<th>B^.-00</th>
							<td>-3.6974155</td>
						</tr>
						<tr>
							<th>C^.-00</th>
							<td>-2.3640818</td>
						</tr>
						<tr>
							<th>D^.-00</th>
							<td>-1.4117008</td>
						</tr>
						<tr>
							<th>E^.-00</th>
							<td>-6.974152 ^-01</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">10ˣ</span>
						выдаёт ошибку не из-за переполнения, а как обычно: порядок вне
						диапазона. Хотя отрицательные значения как результат возведения
						в степень конечно удивляют.
					</p>
					<table class="trcenter">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
						</tr>
						<tr>
							<th>1^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>2^.-00</th>
							<td>-13.02585</td>
						</tr>
						<tr>
							<th>3^.-00</th>
							<td>-36.051703</td>
						</tr>
						<tr>
							<th>4^.-00</th>
							<td>-59.077562</td>
						</tr>
						<tr>
							<th>5^.-00</th>
							<td>-7.0398713</td>
						</tr>
						<tr>
							<th>6^.-00</th>
							<td>-6.4318666</td>
						</tr>
						<tr>
							<th>7^.-00</th>
							<td>-5.5095304</td>
						</tr>
						<tr>
							<th>8^.-00</th>
							<td>-3.9441377</td>
						</tr>
						<tr>
							<th>9^.-00</th>
							<td>-7.0326326^-01</td>
						</tr>
						<tr>
							<th>A^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>B^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>C^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>D^.-00</th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>E^.-00</th>
							<td>1</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">xʸ</span>
						ведёт себя тоже нестандартно.
						Если число N показатель степени, т.е. в регистре Y, то нормально
						работает только если число в X не меньше числа e (экспонента), а
						иначе даёт единицу.
					</p>
					<table class="trcenter">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
							<td>1.^-00</td><td>1</td><td>2.^-00</td><td>2</td><td>3^.-00</td><td>3</td>
						</tr>
						<tr>
							<td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
						</tr>
						<tr>
							<td>2</td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td><td>7.9999993</td>
						</tr>
						<tr>
							<td>2.7182817</td>
							<td>1</td><td>2.7182817</td>
							<td>1</td><td>7.3890551</td>
							<td>1</td><td>20.085531</td>
						</tr>
						<tr>
							<td>2.7182818</td>
							<td>2.7182818</td><td>2.7182818</td>
							<td>7.3890557</td><td>7.3890557</td>
							<td>20.085535</td><td>20.085535</td>
						</tr>
						<tr>
							<td>3</td>
							<td>2.9999994</td><td>2.9999994</td>
							<td>8.9999984</td><td>8.9999984</td>
							<td>26.999992</td><td>26.999992</td>
						</tr>
					</table>
					<p>
						Если N основание, т.е. в регистре X, то ситуация печальней.
						<br>
						1.^-00 работает как обычно, т.е. даёт единицу при любом показателе.
						<br>
						2^.-00 быстро скатывается в ошибку:
					</p>
					<table class="trcenter">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
							<td>2</td><td>2.29</td><td>2.30</td><td>2.31</td><td>2.32</td>
						</tr>
						<tr>
							<td>2.^-00</td>
							<td>5.5355546^-87</td>
							<td>1.7215634^-99</td>
							<td>0(=6.3773317^-100)</td>
							<td>ЕГГ0Г(=2.3624032^-100)</td>
							<td>ЕГГ0Г(просто ошибка аргумента)</td>
						</tr>
					</table>
					<p>
						Для остальных показателей и степеней выдаёт ошибку, кроме степени 1.
						Причем опять идёт изменение уровня начиная с B^.-00.
					</p>
					<table class="trcenter">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
							<td>1</td>
						</tr>
						<tr>
							<td>2.^-00</td><td>7.4401479^-44</td>
						</tr>
						<tr>
							<td>3.^-00</td><td>1.1160242^-43</td>
						</tr>
						<tr>
							<td>4.^-00</td><td>1.4880297^-43</td>
						</tr>
						<tr>
							<td>5.^-00</td><td>1.8600371^-43</td>
						</tr>
						<tr>
							<td>6.^-00</td><td>2.2320432^-43</td>
						</tr>
						<tr>
							<td>7.^-00</td><td>2.6040517^-43</td>
						</tr>
						<tr>
							<td>8.^-00</td><td>2.9760592^-43</td>
						</tr>
						<tr>
							<td>9.^-00</td><td>3.3480707^-43</td>
						</tr>
						<tr>
							<td>A.^-00</td><td>3.7200738^-43</td>
						</tr>
						<tr>
							<td>B.^-00</td><td>2.478751^-02</td>
						</tr>
						<tr>
							<td>C.^-00</td><td>9.4035621^-02</td>
						</tr>
						<tr>
							<td>D.^-00</td><td>2.437284^-01</td>
						</tr>
						<tr>
							<td>E.^-00</td><td>4.9787053^-01</td>
						</tr>
					</table>
				</li>
			</ul>
		</details>

		<details id="div_nzd_func_K" open>
			<summary><h4>"Синие" функции</h4></summary>
			"Синие" функции &ndash; те, которые вызываются через кнопку
			<span class="but_k">К</span>.
			<ul>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">[x]</span>
						считает числа N дробными, и выдаёт ноль.
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">{x}</span>
						считает также, и соответственно, не меняет их, даже
						шестнадцатеричные.
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">max</span>
						работает как обычно, причем она, например, числа 8 и 8^.-00 считает
						равными.
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">|x|</span>
						тоже работает как обычно, т.е. если отрицательное, то минус уберёт,
						а мантиссу и порядок не трогает.
					</p>
				</li>
				<li>
					<p>
						<span class="but_k">К</span><span class="op_k">ЗН</span>
						тоже работает как обычно, т.е. даёт &plusmn;1.
					</p>
				</li>
				<li>
					<p>
						Набор функций
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>,
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>,
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>,
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>,
						которые обычно редко используются, здесь помогают расширить
						диапазон мантисс для чисел N. Дело в том, что они также считают
						такие числа дробными, но в отличии от остальных функций при
						обработке не трогают порядок. Это значит, что число по-прежнему
						остается с нулевой отрицательной степенью (если конечно в результате
						не понизится порядок). Пример:
						<br>
						<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>
						выдаст
						<span class="code">&nbsp;2.9999999-00</span>, если чуть изменить:
						<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>,
						то уже <span class="code">&nbsp;2.9945599-00</span>
						<br>
						Или
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but">/-/</span>
						даст <span class="code">--.16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-00</span>.
					</p>
					<p>
						Понятно, что таким образом набор мантисс ограничен, но всё-таки
						позволяет разнообразить набор чисел N.
					</p>
				</li>
				<li>
					<p>
						Логические функции, как обычно, вообще не обращают внимание на
						порядок и делают свою обычную работу, убирая всё лишнее.
					</p>
				</li>
			</ul>
		</details>

		<details id="div_nzd_sum" open>
			<summary><h4>Итог</h4></summary>
			На практике такие числа могут быть использованы своей двойственностью
			при выполнении вычислений. Т.е. в обычном случае как обычная константа,
			но при определенных условиях вдруг меняющая свое поведение. Главным
			выглядят умножения и деления, и пусть там выходят числа с большим
			отрицательным порядком, фактически любая X2 влияющая команда тут же
			превратит их в обычный ноль.
		</details>
	</details>

	<hr>

	<details id="div_tricks" open>
		<summary><h3>Трюки по оптимизации</h3></summary>
		Здесь рассмотрены некоторые способы, которые позволяют оптимизировать
		программу. Большинство трюков &ndash; это использование документированных
		возможностей, но возможно необычным образом.
		Ясно, что все варианты не рассмотреть, а лишь несколько для
		демонстрации, как нужно нестандартно подходить к вопросу оптимизации.
		<ul>
			<li>
				<strong>Косвенная адресация вместо прямой.</strong> Это очевидное решение,
				т.к. (без)условный переход (или  вызов подпрограммы) занимает две
				команды, а то же самое с косвенной адресацией &ndash; только одну. Чем
				больше таких вызовов, тем выгоднее.
				<p></p>
			</li>
			<li>
				<strong>Правильный порядок в стеке.</strong> Это также
				очевидное решение, при
				котором порядок вычисления меняют так, чтобы операнды по максимуму
				использовали стек (а не регистры памяти), и при этом располагались в
				порядке последующего вычисления. Или ещё &ndash; использование стека
				вычислений для дублирования числа. Пусть некое число нужно многократно
				использовать в вычислениях. Чтобы не вызывать его несколько раз из
				регистра памяти (а может даже и не сохранять), используется следующая
				методика: число вычисляют раньше, чем положено, затем после него
				делаются другие вычисления,  но так, чтобы наше число "дошло" до
				регистра T. Затем другие вычисления завершаются, а регистры стека
				Y&hellip;T остаются заполнены нашим числом (причем и далее будут им
				заполняться). Экономия в командах на вызов из регистра.
				<p></p>
			</li>
			<li>
				<strong>Использования побочной ветви адресного пространства</strong> для
				сокращения программы. Эти способы уже были рассмотрены ранее в
				разделе по <a href="#div_addr_space">адресному пространству</a>.
				<p></p>
			</li>
			<li>
				<strong>Замена <span class="but_b">БП</span>&ensp;
				<span class="but">01</span>	на <span class="but_b">В/О</span>.</strong>
				Это работает, только если стек  возврата адресов пустой (нулевой).
				См. в <a href="#div_command">приложении</a> комментарий по команде
				<span class="but_b">В/О</span>.
				<p></p>
			</li>
			<li>
				<strong>Совмещение адреса перехода и команды.</strong> В этом случае адрес
				перехода для двойных команд (чаще всего <span class="but_b">БП</span>)
				используется одновременно и как обычная команда для другой
				последовательности.  Очевидно, что требуется знание кодов операций.
				Благодаря наличию побочных ветвей адресации или её неоднозначности можно
				"подогнать" адрес под нужную команду. Например, последовательность
				<span class="but_b">БП</span>&ensp;
				<span class="but">53</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="reg">d</span>
				можно заменить на
				<span class="but_b">БП</span>&ensp;
				<span class="but">4D</span>,
				т.к. адрес 4D = 53, а 4D = это
				<span class="but_b">x&rarr;П</span><span class="reg">d</span>.
				<p>
					Иногда ради такой "подгонки" делают перестроение программы:
					перемешивание независимых кусков программы, располагая их по
					разным адресам. Сюда же относится пример из журнала
					<a href="http://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1985-09--num50" target="_blank">
					  ТМ &numero;9 за 1985:
					</a>
				</p>
				<p>
					<span class="code_num">60.</span><span class="but_f">F</span><span class="op_f">x&lt;0</span>&ensp;
					<span class="code_num">61.</span><span class="but">61</span>&ensp;
					<span class="code_num">62.</span><span class="but_f">F</span><span class="op_f">x&ge;0</span>&ensp;
					<span class="code_num">63.</span><span class="but">63</span>&ensp;
					<span class="code_num">64.</span><span class="but_b">С/П</span>
				</p>
				Когда перед остановкой выводилось содержимое нужного регистра при
				проверке условия. Экономия на том, что адрес перехода совпадает с
				командой извлечения из регистра.
				<p></p>
			</li>
			<li>
				<strong>Удаление условных операторов.</strong> Речь идёт о замене условных
				операторов, которые обычно двойные, на простую арифметику.
				Пусть есть часть программы, где при X &ne; 0 нужно к регистру R9
				добавить единицу (некий счётчик). Решение в лоб:
				<p>
					<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">x&ne;0</span>&ensp;
					<span class="code_num">01.</span><span class="but">06</span>&ensp;
					<span class="code_num">02.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
					<span class="code_num">03.</span><span class="but">1</span>&ensp;
					<span class="code_num">04.</span><span class="but">+</span>&ensp;
					<span class="code_num">05.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
				</p>
				Решение с удалением условия:
				<p>
					<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">ЗН</span>&ensp;
					<span class="code_num">01.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
					<span class="code_num">02.</span><span class="but">+</span>&ensp;
					<span class="code_num">03.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
				</p>
				В случае, если X может быть и отрицательным, будет чуть длиннее, но
				всё равно короче прямого решения:
				<p>
					<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">ЗН</span>&ensp;
					<span class="code_num">01.</span><span class="but_k">К</span><span class="op_k">|x|</span>&ensp;
					<span class="code_num">02.</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
					<span class="code_num">03.</span><span class="but">+</span>&ensp;
					<span class="code_num">04.</span><span class="but_b">x&rarr;П</span><span class="but">9</span>
				</p>
			</li>
			<li>
				<strong>Нестандартное использование циклов FLx.</strong>
				<ol>
					<li>
						Знание того, что цикл по завершении оставит единицу позволяет
						не инициализировать его при повторном заходе.
					</li>
					<li>
						Быстрая проверка на единицу содержимого регистров R0&hellip;R3 с
						переходом при невыполнении. Иногда для этой возможности
						переставляют регистры, т.е. специально используется R0&hellip;R4
						вместо других для такой возможности.
					</li>
					<li>
						Выполнение операций, не имеющих отношение к циклу. Например,
						нужно в конце некой подпрограммы уменьшить счётчик попыток в
						регистре R2 и перейти на адрес (пусть 77). Вместо
						<p>
							<span class="code_num">00.</span><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
							<span class="code_num">01.</span><span class="but_b">БП</span>&ensp;
							<span class="code_num">02.</span><span class="but">77</span>
						</p>
						которое, кстати, портит стек (и для исправления может
						потребоваться ещё команда), сделать:
						<p>
							<span class="code_num">00.</span><span class="but_f">F</span><span class="op_f">L2</span>&ensp;
							<span class="code_num">01.</span><span class="but">77</span>
						</p>
						Разумеется, счётчик должен не кончаться или сразу после этого кода
						идёт проверка по его окончанию. При это для "бесконечности"
						счётчика иногда делают его отрицательным, если в конце вычислений важна
						только разница между началом и концом.
					</li>
				</ol>
				<p></p>
			</li>
			<li>
				<strong>Проверка на больше/меньше единицы.</strong> Если известно, что число
				не отрицательное, то вместо отнимания единицы и проверки на
				больше/меньше нуля можно сразу взять
				<span class="but_f">F</span><span class="op_f">lg</span> и проверить на
				больше/меньше нуля.
				<p></p>
			</li>
			<li>
				<strong>Остановка по ошибке при условии.</strong> Вот несколько способов
				сгенерировать ошибку и сделать остановку без проверки условия:
				<ol>
					<li>
						Если ноль &ndash; <span class="but_f">F</span><span class="op_f">1/x</span>
					</li>
					<li>
						Если меньше или равно нулю -
						<span class="but_f">F</span><span class="op_f">lg</span>
					</li>
					<li>
						Если меньше нуля -
						<span class="but_f">F</span><span class="op_f">&radic;</span>
					</li>
					<li>
						Если больше единицы -
						<span class="but_f">F</span><span class="op_f">cos⁻¹</span> или
						<span class="but_f">F</span><span class="op_f">sin⁻¹</span>
					</li>
					<li>
						Если больше или равно 100 -
						<span class="but_f">F</span><span class="op_f">10ˣ</span>
					</li>
					<li>
						Если дробная часть больше или равно 0.6 -
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					</li>
				</ol>
				<p></p>
			</li>
			<li>
				<strong>Вызов части подпрограммы.</strong> Пример, пусть есть некий алгоритм,
				который особым образом обрабатывает число, но только целое или
				дробное отдельно. А нужно сделать её более универсальной, т.е. для
				любого числа. Можно сделать так:
				<p>
					<span class="code_num">00.</span><span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
					<span class="code_num">01.</span><span class="but">0</span>&ensp;
					<span class="code_num">02.</span><span class="but_f">F</span><span class="op_f">Вx</span>&ensp;
					<span class="code_num">03.</span><span class="but_k">К</span><span class="op_k">[x]</span>&ensp;
					<span class="code_num">04.</span><span class="but_b">ПП</span>&ensp;
					<span class="code_num">05.</span><span class="but">07</span>&ensp;
					<span class="code_num">06.</span><span class="but">&lt;-&gt;</span>&ensp;
					<span class="code_num">07.</span>&hellip;&ensp;
					<span class="code_num">20.</span><span class="but">+</span>&ensp;
					<span class="code_num">21.</span><span class="but_b">В/О</span>
				</p>
				Что здесь происходит? Сначала подготавливается на будущее дробная
				часть, затем заталкивается ноль и оставляется целая часть.
				Далее вызывается часть кода (часть кода текущей подпрограммы),
				которая делает обработку над целой частью, а в конце делает сложение
				(с нулем, в данном случае).  Затем целая и дробная часть меняются
				местами и код повторяется, причем в конце сложение уже делает
				объединение, а затем возврат.  Где экономия? Если бы мы вызывали
				обрабатываемую часть по очереди, то нам всё равно потребовалось бы
				разделять на целую и дробную часть, обрабатывать по очереди, а затем
				объединять сложением. Для этого потребовались бы всё те же команды,
				кроме <span class="but">0</span>. Но при это пришлось бы делать дважды
				<span class="but_b">ПП</span>, а это две команды. Заменив на одну команду
				<span class="but">0</span> и вызвав свой "хвост", мы сэкономили одну команду.
				<p></p>
			</li>
			<li>
				<strong>Совмещение констант и адресов перехода.</strong> В данном
				случае речь
				идёт о том, что некоторая константа, используемая для вычислений,
				одновременно содержит и адрес перехода. Иногда это делают
				искусственно, перемещая программу под значение константы, а иногда
				удаётся совместить. Пример из практики автора &ndash; для битового
				положения игрока использовался формат N.0000H, где N &ndash; некий "этаж",
				H &ndash; бит (число 1, 2, 4 или 8), а количество нулей в дробной части
				определяет положение на "этаже". Движение по "этажу" выполнялось над
				дробной частью, путем умножения/деления на два (биты) и путем
				умножения/деления десять (влево/вправо на этаже). Подводный камень -
				в автоматическом округлении ПМК, возникающим при сложении чисел
				разных порядков.   В данном случае при дробной части =
				0.000000H (H.^-07) и делении на 10 получается число "вне этажа",
				H.^-08, которое должно обнулиться. Для H = 1, 2, 4 при сложении с
				целым так и есть, но если H = 8, то происходит исключение: в
				результате округления 8.^-08 превращается в 1.^-07 (неожиданный
				телепорт). Чтобы программа вела себя корректно, необходимо перед
				сложением от полученного числа отнять некое значение в диапазоне
				3.^-08 &les; X &lt; 5.^-08, тогда это не испортит случая
				H = 1, 2, 4, и сделает число с H = 8 обнуляемым при округлении.
				Так вот, используя знание
				<a href="#div_indirect_addr">косвенной адресации</a> можно к
				3.^-08 (или 4.^-08) добавить пару цифр. Это на исправление округления
				не скажется, но позволит использовать эти цифры как адрес перехода.
				Пусть нужна косвенная адресация с адресом 77, тогда константа будет
				3.77^.-08. А если учесть, что при косвенной адресации оно будет
				не нормализовано, то оно же использовалось для видеоизображения особой
				ситуации: <span class="code">&nbsp;0.0000377-03</span>.
			</li>
		</ul>
	</details>

	<hr>

	<details id="div_demo" open>
		<summary><h3>Демонстрационная программа</h3></summary>
		<details id="div_demo_preface" open>
			<summary><h4>Описание интерфейса программы</h4></summary>
			В качестве демонстрации используется <strong>модификация</strong> программы
			"Пещера сокровищ", опубликованной в журнале
			<a href="http://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1987-07--num42" target="_blank">
			  Техника Молодежи №7 за 1987.
			</a>
			<p>
				Для тех, кто не хочет идти по ссылке (или высматривать мелкий шрифт скана)
				опишем игру. Это трехмерный лабиринт (3 этажа размером 7&times;4),
				где каждая ячейка	на этаже может быть или свободна, или
				занята &ndash; "стена". Цель игры &ndash; находясь в некоторой начальной
				точке лабиринта пройти весь (выход в левой нижней точке на третьем
				этаже &ndash; влево) и собрать максимальное количество
				сокровищ.
				Для понимания адресации вот план 1-го этажа из публикации
				в журнале:
			</p>
			<table>
				<tr>
				<td></td><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th>
				</tr>
				<tr>
				<th>1</th>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				</tr>
				<tr>
				<th>2</th>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				</tr>
				<tr>
				<th>4</th>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				</tr>
				<tr>
				<th>8</th>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>X</td>
				</tr>
			</table>
			<p>
				Сверху нумерация колонок, слева &ndash; строк (для битовой арифметики),
				а затемненные ячейки <span class="wall_color">&emsp;</span> обозначают
				стенки. Причем крестиком сразу показано положение игрока (для примера)
				в точке 1.0000008. Именно так расшифровываются координаты:
			</p>
			<ul>
				<li>Целая часть &ndash; номер этажа.</li>
				<li>
				Степень дробной части (количество нулей) &ndash; положение по
				горизонтали (колонка).
				</li>
				<li>Цифра в дробной части &ndash; положение по вертикали (строка).</li>
			</ul>
			<p>
				С учетом этого выход из лабиринта (который предопределен) &ndash;
				влево от точки 3.8.
			</p>
			<p>
				У игрока есть ограниченные ресурсы:
			</p>
			<ul>
				<li>
					Еда (в оригинале вода, но так как храниться в регистре Re, то
					удобнее называть еда). Тратиться при любом ходе.
				</li>
				<li>
					Динамит или гранаты (для запоминания храниться в регистре
					Rd или в обозначении ПМК
					<span class="code">&nbsp;Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>)
					&ndash;	используется для пробивания стенок (их уничтожения).
				</li>
				<li>
					Просто сокровища (хранится, аналогично, в Rc). Именно их нужно набрать
					побольше. В данной модификации реально набрать не меньше десяти
					(за одну игру).
				</li>
			</ul>
			<p>
				Ресурс можно пополнить, поискав его (т.е. его может и не быть).
				Поэтому далее будем называть их кладами. При это
				на 1-м этаже будет еда (+9, в оригинале +10), на 2-м &ndash; динамит (+4)
				и только на 3-м сокровища (+1). Особенность &ndash; как только нашли, то
				на всех этажах в той же ячейке кладов уже нет.
			</p>
			<p>
				Управление игрока &ndash; задание команды на движение, или поиск кладов,
				или подрыв стены (последней ячейки, где не удалось пройти). Каждая команда
				расходует еду (подрыв, понятно, ещё и динамит). Код направления движения
				определяется положением цифр на клавиатуре относительно центра:
				2,4,6,8,&plusmn;5 &ndash; вниз/влево/вправо/вверх и выше/ниже этажом.
				Подрыв стены нулем (в оригинале число
				<span class="but_f">F</span><span class="op_f">&pi;</span>, но обычно
				при неудаче прохода выдаёт 0, так что сразу и удобнее его
				использовать для команды подрыва).
				Поиск &ndash; число 10 (в оригинале ноль, но 1/0 как бы намекает
				на найдем/нет).
			</p>
			<p>
				Если движение прошло успешно, то по окончании отображается новая
				координата игрока (в кодировке, как описано выше). Если нет &ndash; ноль.
				Выход из лабиринта определяется числом 11
				(в оригинале трамвай 11-го маршрута).
			</p>
			<p>
				При поиске клада: если не найдено &ndash; ноль.
				Если найдено, то показывает новое количество ресурса,
				а в регистре Y букву типа клада и позицию, где нашли, например:
				<span class="code">&nbsp;E.00002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>.
				При этом (как в оригинале) с разбойником, который защищал клад, можно
				бороться (<span class="but">В&uarr;</span>) или пропустить
				(<span class="but">0</span>), затем <span class="but_b">С/П</span>.
				Если боремся, то в результате общее количество (с
				учетом найденных кладов) данного ресурса может как увеличиться, 
				так и уменьшиться.
			</p>
			<p>
				При успешном подрыве &ndash; новое положение игрока, т.е. подрыв
				подразумевает сразу ход в новую ячейку (в оригинале для этого приходилось
				делать отдельный ход). При неудаче &ndash; ноль.
			</p>
			<p>
				Несколько отличий демонстрационной программы от оригинала уже было сказано,
				но приведем весь список:
			</p>
			<ul>
				<li class="li_change">
					Для подрыва используется два динамита (всё-таки программа сложнее &#9786;).
					На самом деле, изменен способ отображения нехватки еды/динамита, и
					чтобы их отличить используется такое "увеличение".
					Соответственно добавляется не по два, а по четыре, и вначале даётся
					не два, а четыре.
				</li>
				<li class="li_change">
					При нехватке динамита или еды вместо ЕГГ0Г отображается
					соответственно -1 или -2	(еда или динамит).
				</li>
				<li class="li_add">
					Подрыв определяется числом ноль (а не <big>&pi;</big>), причем
					игрок сразу делает	ход в новую ячейку (иначе зачем подрыв?).
				</li>
				<li class="li_add">
					Поиск определяется числом 10, а не ноль. Кроме буквы типа
					показывается и положение клада на этаже (в оригинале только буква).
					Например <span class="code">&nbsp;E.00002</span>.
				</li>
				<li class="li_add">
					Стенки удаляются, а не делается "xor". Хотя можно сделать в коде и так
					(поменяв <span class="but_k">К</span><span class="op_k">&or;</span>
					на <span class="but_k">К</span><span class="op_k">&oplus;</span>), но
					ставить новые стенки для затруднения прохода на мой
					взгляд нецелесообразно.
				</li>
				<li class="li_add">
					Блокируется неожиданный "телепорт" из N.0000008 в N.0000001 при
					движении вправо (сказываются особенности округления). В оригинале
					автор в примере в нескольких местах поставил стенки, чтобы
					это не проявлялось.
				</li>
				<li class="li_add">
					Блокируется подрыв "капитальных" стен. Это которые по краям лабиринта
					(слева, справа, сверху, снизу в том числе подвал и крыша).
					В оригинале это можно делать, что приводило к непредсказуемым
					результатам.
				</li>
				<li class="li_add">
					Не портиться стек возврата. В оригинале при ЕГГ0Г не отрабатывала
					команда <span class="but_b">В/О</span>, что забивало стек возврата. Хотя
					на работу самой программы это и не сказывалось.
				</li>
				<li class="li_add">
					Начальное значение счётчиков (кроме сокровищ) заполняются
					автоматически программой. Не требуется вводить в начале игры. Понятно,
					что и "начало" сделано по-другому.
				</li>
				<li class="li_add">
					И <strong>главное</strong> &ndash; ПМК сам(!) генерит как лабиринт, так и
					расположение кладов (в оригинале нужно было самому разработать,
					закодировать и вбить лабиринт) при каждой новой игре, причем начальное
					положении игрока обеспечивается "не в стенке". Получается, что в отличии от
					оригинала у игрока нет плана лабиринта и кладов. С учетом этого было
					принято решение немного увеличить начальный объем еды
					(36 против исходных 30), т.к. план неизвестен и придётся
					многократно упираться в стенки при изучении. Также подрыв стены
					совмещен с ходом на новое место.
				</li>
			</ul>
		</details>

		<details id="div_demo_detail" open>
			<summary><h4>Разбор программы</h4></summary>
			Полный код программы приведем в конце, а по ходу изложения будем
			приводить фрагменты, изучая трюки и использование недокументированных
			особенностей ПМК, без которых не удалось обойтись, с учетом всех
			улучшений. Сначала общий алгоритм программы. Как в оригинале
			сказано, это демонстрация возможностей ПМК работать с отдельными битами
			(шестнадцатеричные числа). Планы этажей и кладов представляются
			битовыми масками (хватает одного числа на весь этаж), а местоположение
			игрока	фактически определяет один бит. Именно он "двигается",
			накладываясь на битовые маски, определяя возможность пройти.
			Так же биты в масках удаляются (при взятии клада) или устанавливаются
			(при удалении стенок).
			Большая часть кода программы &ndash; это преобразование хода игрока в
			правильные битовые операции, проверка границ, ресурсов и т.п.
			<p>
				Распределение регистров во многом совпадает с оригиналом.
			</p>
			<ul>
				<li>R0 &ndash; план кладов.</li>
				<li>R1&hellip;R3 &ndash; план 1&hellip;3 этажей.</li>
				<li>
					R4&hellip;R7 &ndash; специальные числовые константы для преобразования
					движения в битовую операцию: 2; 10; 0.1; 0.5 (точнее вместо 0.1 другое
					число, но смысл тот же). Т.е. берётся дробная часть положения игрока
					(положение на этаже) и производится умножение на указанные величины,
					как бы сдвигая бит вниз (2), влево (10), вправо (&#8530;) и вверх (&frac12;).
					В оригинале это всё вычисляется программно, но я предпочел убрать
					в регистры памяти, чтобы  освободить большего место для команд.
					Хотя это и привело к дефициту регистров памяти.
				</li>
				<li>
					R8, R9 &ndash; содержат вспомогательные константы для адресов перехода
					и др., которые так же не меняются между играми. Детальное значение ниже
					по ходу изложения.
				</li>
				<li>
					Ra &ndash; текущее положение игрока в кодировке, указанной в
					описательной части.
				</li>
				<li>
					Rb &ndash; будущее положение игрока (куда он не смог пройти). Так же
					этот регистр (всего один!) используется как рабочий для всевозможных
					вычислений, поэтому при "не ходах" там может быть совсем другое
					значение, но в любом случае подрыв контролирует и это.
				</li>
				<li>
					Rc, Rd, Re, как было указано выше, используются для хранения ресурсов
					(сокровища/динамит/еда).
				</li>
			</ul>
			<p>
				Итак, начнем с&hellip; начала. Как начинается игра (предполагая что глобальные
				константы вбиты, как и сама программа)? А вот так: задаётся начальное
				положение игрока на плане, например
				<span class="code">&nbsp;1.0000001&nbsp;&nbsp;&nbsp;</span>, затем
				<span class="but_b">БП</span>&ensp;
				<span class="but">48</span>&ensp;
				<span class="but_b">С/П</span>.
				Тут же фрагментик:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td colspan=8></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">6</span></td>
				</tr>
				<tr>
					<th>&#8202;50&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
					<td colspan=7></td>
				</tr>
			</table>
			<p>
				Положение игрока запоминается в Rb (как бы куда хотим пойти). Начальное
				количество динамита берем 6, а не 4, т.к. два придётся потратить на
				удаление возможной стенки в месте игрока &ndash; мы же ещё не знаем
				лабиринт. 36 (6&sup2;) &ndash; как начальное количество еды.
				А вот с регистром R0 проводим хитрые манипуляции. Благодаря особенностям
				косвенной адресации при первом	обращении ноль превратится
				в -99999999, что соответствует регистру R3, затем в -99999998 &ndash; R2
				и так пока	не дойдет до R0, где -99999996 перепишется новым
				сгенерированным значением (уже положительным!), это и отслеживаем в цикле.
				Цикл возвращается на адрес 55, который и
				записан в R8 (точнее -55, но на адресацию это не влияет, а почему минус
				объясню позже).
				Сами операнды для
				<span class="but_k">К</span><span class="op_k">&or;</span>  получаются из
				<span class="but_k">К</span><span class="op_k">СЧ</span> через функции
				<span class="but_f">F</span><span class="op_f">10ˣ</span> и
				<span class="but_f">F</span><span class="op_f">xʸ</span>,
				которые "размазывают" цифры мантиссы случайного числа на все
				разряды и делают его более случайным. 
				Причем испытания показали, что выгодней сделать
				<span class="but_f">F</span><span class="op_f">Вx</span> и
				<span class="but_f">F</span><span class="op_f">xʸ</span> вместо
				повтора <span class="but_k">К</span><span class="op_k">СЧ</span> и
				<span class="but_f">F</span><span class="op_f">10ˣ</span> для
				второго операнда (таки циклиться датчик, а эти операции его "сбивают").
				Любители усложнения лабиринта (больше стенок и меньше кладов), могут
				заменить
				<span class="but_k">К</span><span class="op_k">&or;</span> на
				<span class="but_k">К</span><span class="op_k">&oplus;</span>
			</p>
			<p>
				Следующий фрагмент, это снова начало&hellip;, но уже в программном виде
				(я отображаю фрагменты так, чтобы было понятнее позднее что и как):
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">В/О</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan=8></td>
				</tr>
			</table>
			<p>
				Да, такой вот маленький фрагмент, поэтому явно требуются пояснения.
			</p>
			<p>
				Для начала хочу обратить внимание, что в R7 у нас записано 0.5, что
				при косвенной адресации даёт нулевой адрес (не меняя R7), а это значит,
				что мы всегда можем быстро вернуться на начало через
				<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span>,
				или подобное. Поэтому <span class="but_b">С/П</span> и располагается в
				самом начале.
			</p>
			<p>
				Но, есть и другой момент.
				Можно расположить в конце адресного пространства подпрограмму без
				<span class="but_b">В/О</span>, т.к. благодаря побочной ветви адресного
				пространства этот <span class="but_b">В/О</span> "сыграет". Более того,
				могу сразу сказать, что несмотря на наличие четырёх логических подпрограмм
				программа содержит всего этот один <span class="but_b">В/О</span>.
				Две подпрограммы	удалось наложить на хвост другой, а
				начальный <span class="but_b">В/О</span>
				смог "сыграть" в двух разных адресных побочных ветвях.
			</p>
			<p>
				Иногда разницу в методах возврата используют для различения
				ситуации. Например, в оригинале в начале стоит
				<span class="but_cx">Cx</span>, куда возвращается управление при неудаче,
				или на +01 при удаче. Но мне удалось
				сэкономить даже на этой команде. Позднее поясню как.
			</p>
			<p>
				Прежде, чем продолжить код инициализации, который мы бросили, хочу
				привести <strong>основную</strong> подпрограмму, которая делает битовую
				проверку.
				Сначала приведем формализацию: на входе ожидается в регистре X
				план этажа для проверки (битовая маска). В регистре Y положение игрока (бит).
				После исполнения: значение Y безусловно запишется в регистр Rb.
				Если битовая проверка прошла успешно (совпадение), то значение из Y также
				попадет в регистр Ra, в Y останется дробная часть (положение на этаже),
				а само значение будет уже в X.
				Если битовая проверка не успешна, то вернет ноль в регистрах X и Y.
				Посмотрим, как это делается.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">max</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
					<td colspan=2></td>
				</tr>
			</table>
			<p>
				Если с битовым умножением и копированием Y в Rb всё ясно, то вот
				<span class="but_k">К</span><span class="op_k">max</span> явно использован
				"недокументировано". При неудаче ноль из регистра Y будет
				"недокументировано" скопирован как "самое большое число" в X. Т.е.
				при неудаче будет ноль (что от подпрограммы и требуется).
				А если битовая операция успешная (есть дробная часть), то ничего
				не произойдёт (т.е. исходный Y останется в X, а дробная часть в Y).
				И результат будет скопирован в Ra.
			</p>
			<p>
				На самом деле эта подпрограмма полезна ещё в другом случае. Если
				(на входе) в одном из регистров X или Y число состоит из одной цифры,
				то	эта процедура безусловно даст на выходе ноль. Эта возможность
				тоже используется в программе, поэтому назовем её также
				процедурой <strong>очистки</strong>.
			</p>
			<p>
				Но внимательный читатель спросит, а где же <span class="but_b">В/О</span>?
				А он расположен по адресу... ноль!
				Так вот, тут используется побочная ветвь адресного пространства, но
				только не после 105 адреса, а после F9-го. Да, адрес F9 = 47, а значит
				если подпрограмма начинается не с адреса 41 (как будто), а с того же
				адреса, но как F3, то после адреса F9 (47) управление перейдет
				на 00, т.е. на ту самую <span class="but_b">В/О</span>.
			</p>
			<p>
				Здесь уже уже можно раскрыть, что константа с регистре R9 (он
				используется для вызова этой подпрограммы) заканчивается на F3
				(можно и на ED). Точнее в R9 храниться
				<span class="code">&nbsp;4.&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</span>
				(или <span class="code">&nbsp;4.EГ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</span>,
				кому как больше нравиться). Зачем вначале идёт 4 и такой порядок будет
				пояснено позднее (хотя если читали весь документ, то об этом уже
				упоминалось). Главное, что такой "довесок" не меняет косвенной
				адресации.	Упомяну только, что после "использования" в
				косвенной адресации значение в R9 станет не нормализованным
				<span class="code">&nbsp;0.00004 3-03</span>,
				зато сразу покажет адрес перехода.
			</p>
			<p>
				Продолжим код инициализации (начальной генерации лабиринта). Точнее
				он уже закончился и плавно	переходит в подпрограмму, которая
				"взрывает" стенки. В чем смысл такого	"слияния"? Во-первых не
				требуются какие либо <span class="but_b">БП</span>,	во-вторых, нам
				всё равно нужно обеспечить, чтобы в точке высадки стенок
				не было, т.е. как бы убрать её (даже если её там не было).
				Вот поэтому и было вначале на две динамита больше. Итак:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td colspan=3></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td colspan=2></td>
				</tr>
			</table>
			<p>
				Тут вроде понятно, что из ресурса динамита (Rd) убирается два, проверяется
				что что-то осталось (не отрицательное) и остаток сохраняется обратно.
				Если динамита не осталось, то переходит на начало, с этой "-2", что по
				смыслу программы и нужно для сигнализации, что динамита нет. Причем
				сохранение остатка делается после проверки, чтобы не было -2, -4, -6 и т.д.
				Продолжим.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td colspan=8></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">4</span></td>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
					<td colspan=3></td>
				</tr>
			</table>
			<p>
				Напомню, что координаты взламываемой стены находятся в Rb. Вначале
				проверяем, что это значение в пределах регистров R1&hellip;R3
				(т.е. &lt; 4),	причем R0 тоже пройдет проверку, но это не страшно
				и вот почему.
				На самом деле в Rb число	меньше единицы может быть или в виде одной цифры
				(например, хотели с первого этажа 1.0002 пойти вниз и получили 0.0002)
				или просто ноль (есть такой путь при попытке выхода за границы этажа).
				Главное, что число будет из одной цифры, т.е. со второго разряда цифр нет,
				а значит в этом случае план этажа извлечется из плана кладов R0,
				потому что косвенная адресация через Rb будет равна нулю (да,
				последние две цифры мантиссы будут нулевыми, даже для числа 1.^-07,
				что можно посмотреть в главе по косвенной адресации). Затем операция
				<span class="but_k">К</span><span class="op_k">&or;</span> ничего не
				изменит (нет цифр у второго операнда) и вернет обратно в R0 значение
				неизменным.
				А если число больше или равно 4, то мы перейдем на процедуру очистки
				(зануления) через регистр R9. С учетом работы остальной части программы
				(это можно потом прикинуть) для Rb >= 4 число в Rb либо состоит из
				одной цифры (взлом левой стенки) и процедура очистки безусловно
				сработает, либо это "крыша" (Rb = 4.{&hellip;}). Но в R4 у нас тоже константа из одной цифры,
				а значит процедура очистки тоже сработает.
			</p>
			<p>
				Для R1&hellip;R3 это операция установит бит из Rb	в плане этажа.
				В этом случае в X у нас план этажа, в Y точка взлома, которую мы тут
				устанавливаем. В этом случае основная процедура успешно пройдет битовую
				проверку (мы же только что этот бит поставили) и завершиться, записав
				новое расположение в регистре Ra. Т.е. мы сразу сделаем ход в новое место.
			</p>
			<p>
				Итак. Инициализация закончена. Игрок в точке высадки, стенки там нет.
				Мы познакомились с основной процедурой из регистра R9, она же процедура
				очистки и процедурой взлома стены (с адреса 63), которая тщательно
				проверяет все	варианты. Теперь можно вернуться на точку остановки
				(начальный <span class="but_b">С/П</span>) и 	начать самый частый (основной) код:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td colspan=2></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td colspan=2></td>
				</tr>
			</table>
			<p>
				Тут, очевидно, уменьшается еда, похожим образом, как динамит, учитывая,
				что будет выдано -1 при неудаче. Обращаю внимание, что если
				исключить наш случай, когда регистров просто не хватает, тут всё равно
				делается экономия на команде. Всё-таки
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">R</span> &ndash; это
				две команды, а <span class="but">&lt;-&gt;</span> &ndash; только одна.
				Но это конечно при условии, что запомненное значение не понадобиться ещё раз.
				Далее.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td colspan=8></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">63</span></td>
					<td colspan=8></td>
				</tr>
			</table>
			<p>
				Вот и проверка команды на взлом стены. "Но позвольте, зачем сначала
				деление, а только потом проверка на ноль?" спросите вы. Ответ в том,
				что нам не	хватает регистров (кстати, обратите внимание, что рабочий
				регистр Rb с последней попытки хода пока не задействован, и взлом
				будет на его основе). Поэтому выбор пользователя (точнее получается
				уже полвыбора &#9786;) мы запоминаем в регистре&hellip; X2. Да, да,
				вспомните, ведь проверка условий при успехе запоминает X в X2. А дальше
				посмотрим, как мы это используем:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td colspan=2></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">ВП</span></td>
					<td colspan=4></td>
				</tr>
			</table>
			<p>
				Ага, вот и выбор пользователя преобразован в номер регистра для
				коэффициента умножения. Для прояснения, приведу таблицу с возможным выбором
				игрока (ноль уже исключили), и то, что попало в регистр Rb:
			</p>
			<table class="trcenter">
				<tr>
					<th>Ход игрока</th><th>После &divide; 2</th><th>После + 3</th>
				</tr>
				<tr>
					<th>2</th><td>1</td><td>4</td>
				</tr>
				<tr>
					<th>4</th><td>2</td><td>5</td>
				</tr>
				<tr>
					<th>&plusmn;5</th><td>&plusmn;2.5</td><td>Что-то больше нуля</td>
				</tr>
				<tr>
					<th>6</th><td>3</td><td>6</td>
				</tr>
				<tr>
					<th>8</th><td>4</td><td>7</td>
				</tr>
				<tr>
					<th>10</th><td>5</td><td>8</td>
				</tr>
			</table>
			<p>
				Вариант &plusmn;5 не будет использовать	регистр Rb, как мы увидим позднее.
			</p>
			<p>
				Обратите внимание, что мы на самом деле сложили не с тройкой, а с
				числом <big>&pi;</big>. Почему? Дело в том, что команда
				<span class="but_f">F</span><span class="op_f">&pi;</span> не X2-влияющая,
				к тому же при косвенной адресации дробная часть значения не имеет
				(вспоминаем &ndash; всё это из главы по косвенной адресации).
				Т.е. для нас всё равно, будет в Rb число 7 или 7.1415926, при
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>
				он всё равно извлечет 0.5 (значение в R7).
			</p>
			<p>
				А самое главное, это то, что останется после
				команды <span class="but">ВП</span>.
				Вспомним из главы про X2, что сочетание этой команды с предшествующей
				командой сохранения в регистр "съест" первую цифру числа из X2
				(важно ещё то, что в результате сложения с <big>&pi;</big> значение в X
				не отрицательное) и восстановит его в X. А что у нас в X2?
				Это значение во второй колонке таблицы выше. Т.е. он для всех
				вариантов из таблицы оставит ноль, и
				только от &plusmn;2.5 оставит &plusmn;0.5.
				Вот сколько может сделать одна недокументированная команда!
				Далее обработка варианта с вверх/вниз (&plusmn;0.5):
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td colspan=6></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">D4</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_b">БП</span></td>
					<td><span class="but">EA</span></td>
					<td colspan=8></td>
				</tr>
			</table>
			<p>
				Что он делает? Он преобразует движение между этажами &plusmn;0.5
				в &plusmn;1 (тоже, кстати, трюк  вместо умножения на 2) и переходит
				на некий адрес EA. 
				Другие движения будут обработаны с адреса D4 
				(если кто не знает, при наборе программы и вводе таких
				адресов вместо цифр нажимаются кнопки с соответствующими буквами).
				Что за странные адреса, спросите вы? А дело в том, что в конце всё
				это закончиться на основной процедуре, которая расположена по
				нестандартным адресам, а значит и текущую ветвь выполнения нужно
				"завернуть".
				D4 &ndash; тот же адрес 22, т.е. как раз окончание этого
				кода, а EA равно 38. Точнее, адресу 38 соответствует адрес F0, но
				такое не ввести, поэтому мы заменяем аналогом (трюк).
				Ладно, займемся этим адресом, когда туда дойдем, а сейчас продолжим
				движение по этажу (или проверку клада), но сначала таинственное
				пропускание вперед:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan=2></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
					<td colspan=7></td>
				</tr>
			</table>
			<p>
				Так, пришла пора раскрыть, что же находится в регистре R6, которое
				почти 0.1. Там храниться число D.^-02
				(<span class="code">&nbsp;Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>).
				Дело в том, что в операции умножения, если D находится слева (в X), то
				оно ведёт себя как 10 (кто забыл, просмотрите главу про шестнадцатеричную
				арифметику), а для степени -02 получается как 0.1
				(10 &times; 10⁻² = 10⁻¹). А когда справа (в Y), то
				гораздо хитрее. Это "хитрее" нам понадобится позднее, поэтому пока
				загоняем число в стек, чтобы оно было "справа" (я мысленно стек
				представляю как X1&ndash;X&ndash;Y&ndash;Z&ndash;T, если кто-то по другому,
				то "справа" поменяйте на другое).
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan=3></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">77</span></td>
					<td></td>
				</tr>
			</table>
			<p>
				Ну вот, наконец-то умножение дробной части числа Ra (положение на этаже)
				на коэффициент движения (не забыли, что у нас в Rb?). Тут же проводится
				отсечка варианта поиска клада. Дело в том, что в R8
				(вариант 10 / 2 + 3)
				число отрицательное (-55, если кто забыл, и вот оказывается для чего 
				минус), а	значит поиск уходит на адрес 77. Но это не всё.
				Тут мы опять используем регистр X2 (через X2-влияющую операцию сравнения).
				Мы сохраняем новое положение игрока на этаже в X2, но не потому что нет
				регистра, а для экономии команд:
				<span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="reg">b</span> это две
				команды, а <span class="but">.</span>, всего одна, а сравнение всё равно
				нужно делать. Именно поэтому сравнение делается не сразу после
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>,
				а после умножения, чтобы запомнить в X2 итог.
			</p>
			<p>
				Так, теперь, после получения нового значения на этаже нам нужно проверить,
				что в результате мы не вышли за границы этажа. Изучим такую
				проверку подробнее.
			</p>
			<p>
				Рассмотрим для начала левую границу. Как мы можем за нее попасть? Только
				если перед этим было число M.N (M=1,2,3; N=1,2,4,8), а затем мы N
				умножили на 10. Понятно, что потом мы "дробную" часть приплюсуем к
				этажу M. В данном случае она очень даже не дробная, но в результате
				сложения итоговых вариантов не так много, и самое главное, они будет в
				диапазоне 2&hellip;11 и состоять только из одной цифры (кроме 11). А одна
				цифра бинарную конъюнкцию
				(<span class="but_k">К</span><span class="op_k">&and;</span>)
				"не переживет" в процедуре очистки. Вариант c 11 (влево от 3.8) &ndash;
				это исключение, поэтому он и выбран как выход из лабиринта.
				Причем будет выполнена операция
				<span class="but">1</span>
				<span class="but">1</span>
				<span class="op_k">&and;</span>
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>.
				Т.е. даже регистр Rb (b = 11, кто забыл) выбран не случайно
				(трюк с подтасовкой регистров)!
				В общем, левая граница "защитилась" автоматически.
			</p>
			<p>
				Правая граница. Там значение дробной части становится порядка 1.^-08
				и при сложении с номером этажа просто потеряется
				(точности не хватит на 9 цифр), опять же оставляя только
				одну целую часть, которая будет 1&hellip;3 и конъюнкцию не переживет.
				Исключение составляет 8.^-08 (округление до 1.^-07), но и его мы
				победим позднее.
			</p>
			<p>
				Верх и низ. При переходе верхней границы (1 &times; 0.5) получается число,
				оканчивающиеся на 5, а при переход нижней (8 &times; 2), число из двух цифр.
				Вот тут нам и пригодится таинственное D.^-02 из R6. Используя знания
				шестнадцатеричной арифметики можно узнать, что при умножении
				(D.^-02 как раз осталось справа) на число 1, 2, 4 или 8 результат будет
				содержать только одну цифру, а на 5 и тем более 16 уже больше.
				Это поясняет последующий код:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan=9></td>
					<td><span class="but">&times;</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
					<td colspan=7></td>
				</tr>
			</table>
			<p>
				Здесь кроме того, что указано, применяется ещё один трюк. После умножения
				будет число с одной или более цифрой.
				Как же вычислить одна или больше? Приходит на помощь операция
				<span class="but_k">К</span><span class="op_k">&or;</span>
				при том, что в регистре Y остался ноль ещё после
				команды <span class="but">ВП</span> по адресу 15 (какой автор
				предусмотрительный, даже давний ноль у него при деле &#9786;).
				В результате
				будет 8. &ndash; всё хорошо или 8.{с чем-то} &ndash; плохо, а после
				<span class="but_k">К</span><span class="op_k">{x}</span> либо ноль,
				либо 0.{что-то}. Вот это плохое "что-то" последняя команда и отправит
				на процедуру очистки. Для очистки важно, чтобы в одном из регистров X
				или Y было число с одной	цифрой &ndash; число ноль в Y
				вполне подходит (да, в логических бинарных операциях второй
				операнд не исчезает, но это таки документировано).
				Продолжим далее.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td colspan=3></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">-</span></td>
					<td colspan=4></td>
				</tr>
			</table>
			<p>
				Первое что мы делаем, это восстанавливаем X2 (новое положение на этаже)
				ещё с команды сравнения по
				адресу 17, т.к. все команды в промежутке были не X2-влияющие. А потом
				корректируем значение на маленькую величину порядка 4^.-08. Это не
				изменит итог ни для кого, кроме 8.^-08. В этом случае оно тоже станет
				очень маленьким. Вот где заблокирован "телепорт" и вот зачем в R9 к
				адресу переход были добавлены четвёрка вначале и порядок -08.
				Далее проще:
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td colspan=6></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td colspan=9></td>
				</tr>
			</table>
			<p>
				Мы к нашему новому значению на этаже прибавляем номер этажа
				(целая часть Ra), заталкиваем новые координаты в Y, а в X оставляем план
				этажа. На самом  деле в Rb могло получится не только 1&hellip;3, но и
				другое, поэтому идёт переход на основную процедуру (она идёт
				следом с адреса 41 = F3, и мы её уже смотрели), которая отбросит все
				нестандартные этажи (одна цифра в числе), а также случай, когда битовая
				карта этажа просто не совпадет с положением игрока. Обращаю внимание, что
				основная процедура запомнит в Rb полное значение нового положения, т.е.
				если даже по этажу не пройти, мы запомним точку, куда
				хотели попасть. В случае удачи эта процедура автоматически обновит
				содержимое Ra.
			</p>
			<p>
				Вспомним про адрес перехода 38 = EA, куда мы попадаем при движении между
				этажами. Оказывается &ndash; банальный плюс, но с учетом раннего
				&plusmn;1 и извлеченного Ra, это "то, что доктор прописал" (вверх/вниз).
				Так вариант с движение вверх/вниз плавно влился в текущий кусок
				кода (очередной трюк).
			</p>
			<p>
				Ну вот основная часть кода рассмотрена, остался поиск клада (и разбойник!).
				Там тоже не всё так просто.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td colspan=7></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td colspan=6></td>
				</tr>
			</table>
			<p>
				Тут мы для проверки битов (возможности взять клад) пользуемся
				основной процедурой. При этом в регистр Y ставим содержимое Ra, чтобы
				при удаче, оно же и сохранилось в Ra (это факт действия основной процедуры).
				Понятно, что если кладов уже нет (убран бит в нужном месте), то
				по нулю уходим на начало. Далее убираем бит клада из маски
				в регистре R0.
			</p>
			<p>
				А теперь мы приведем код, который из номера этажа получит
				шестнадцатеричную цифру, из соответствия 1 = E, 2 = D, 3 = C. 
				В оригинале автор использовал для этого заранее сохраненную 
				константу "E" и цикл с уменьшением её через регистр R0. 
				Мы сделаем тоже самое без
				использования дополнительных регистров и короче, пользуясь
				недокументированными возможностями.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td colspan=4></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td colspan=9></td>
				</tr>
			</table>
			<p>
				Тут снова придётся вспомнить раздел про регистр X2 и команду
				<span class="but">ВП</span>, которая восстанавливает его. Сначала с помощью
				сложения с 10 (константа из R5)	мы номер этажа загоняем во второй разряд.
				Тут порядок операндов важен, т.к. последний
				<span class="but_b">П&rarr;x</span> и будет содержаться в X2.
				Затем с помощью инверсии и отсеканию целой части (первой цифры)
				мы получим, что нужная буква находится в первом разряде. Но в X вроде
				ещё что-то есть? Так вот, восстановление X2 через
				<span class="but">ВП</span>, сделает так, что
				при восстановлении X2 только первая цифра останется из X, т.е. 2.00004
				восстановиться в D.00004. То, что нам нужно. Ещё нужно помнить, что перед
				<span class="but">ВП</span> должна быть любая не X2-влияющая команда,
				которая будет выполнена, но результат проигнорирован. Обычно для этих
				целей используется <span class="but_k">К</span><span class="op_k">НОП</span>,
				но мы используем <span class="but_k">К</span><span class="op_k">СЧ</span>. Дело
				в том, что основная процедура может использовать
				<span class="but_k">К</span><span class="op_k">max</span> с нулем в Y, а это
				"сбрасывает" датчик случайных чисел. Для последующих игр
				(вдруг захочется пройти другой лабиринт) желательно "оживить" датчик
				случайных чисел ("с паршивой овцы хоть шерсти клок" &ndash; даже
				из игнорируемой команды пытаемся получить эффект). Идем далее.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">С/П</span></td>
					<td></td>
				</tr>
			</table>
			<p>
				Сохраняем полученную букву с дробной частью в Rb и оставляем его в стеке
				для информации игроку. Потом не только извлекаем старое значение ресурса,
				но и заодно отсекаем дробную часть от буквы (при косвенной адресации),
				чтобы потом преобразовать её в нужную добавку.
				Тут нужно пояснить, что именно происходит для вычислении "добавки", в
				зависимости от значения регистра X (C, D или E).
				При вычитании срабатывают правила шестнадцатеричной арифметики.
			</p>
			<table class="trcenter">
				<tr>
					<th>X</th>
					<th>После "&minus; 1"</th>
					<th>После x&sup2;</th>
				</tr>
				<tr>
					<th>C</th>
					<td>1</td><td>1 (сокровище)</td>
				</tr>
				<tr>
					<th>D</th>
					<td>2</td><td>4 (динамит)</td>
				</tr>
				<tr>
					<th>E</th>
					<td>3</td><td>9 (еды)</td>
				</tr>
			</table>
			<p>
				Код борьбы с разбойником полностью взят из оригинала. Главное,
				чтобы переключатель Р-ГРД-Г был в положении Р. Окончательное значение
				ресурса сохраняется.
			</p>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td colspan=9></td>
					<td><span class="but_f">F</span><span class="op_f">sin</span></td>
				</tr>
				<tr>
					<th>&#8202;A0&#8202;|&#8202;</th>
					<td><span class="but">1</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td colspan=5></td>
				</tr>
			</table>
			<p>
				Вот собственно и всё, финальный <span class="but_b">В/О</span>
				по адресу A5 (или 00) "сыграет", чтобы "сбить" программу с малой
				побочной ветви и вернуть в нормальное русло.
			</p>
		</details>

		<details id="div_demo_full" open>
			<summary><h4>Полный текст программы</h4></summary>
			<table class="trcenter">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">В/О</span></td>
					<td><span class="but_b">С/П</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">63</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">D4</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_b">БП</span></td>
					<td><span class="but">EA</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">77</span></td>
					<td><span class="but">&times;</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">max</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">6</span></td>
				</tr>
				<tr>
					<th>&#8202;50&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_f">F</span><span class="op_f">10ˣ</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_f">F</span><span class="op_f">xʸ</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">4</span></td>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&sup2;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">С/П</span></td>
					<td><span class="but_f">F</span><span class="op_f">sin</span></td>
				</tr>
				<tr>
					<th>&#8202;A0&#8202;|&#8202;</th>
					<td><span class="but">1</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td colspan=5></td>
				</tr>
			</table>
			<p>
				Начальные значения констант (которые не меняются между играми):
			</p>
			<ul>
				<li>R4 = 2</li>
				<li>R5 = 10</li>
				<li>R6 = D.^-02
					(<span class="code">&nbsp;Г.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-02</span>
				</li>
				<li>R7 = 0.5</li>
				<li>R8 = -55 (с минусом)</li>
				<li>
					R9 = 4.F3^-08
					(<span class="code">&nbsp;4. 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-08</span>
				</li>
			</ul>
			<p>
				Вот последовательность для ввода констант:
				<br>
				<span class="but">5</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">8</span>
				<br>
				<span class="but">4</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">В&uarr;</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_k">К</span><span class="op_k">&or;</span>&ensp;
				<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">9</span>
				<br>
				<span class="but">1</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">5</span>
				<br>
				<span class="but">2</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">4</span>
				<br>
				<span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">7</span>
				<br>
				<span class="but">2</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
				<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="op_k">[x]</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">6</span>
			</p>
			<p>
				Положение переключателя Р-ГРД-Г должно быть в Р.
				Перед первой игрой (или каждой, если не хотите аккумулировать сокровища)
				регистр Rc нужно обнулить.
			</p>
			<p>
				И напомню порядок начала игры: задаётся начальное положение игрока на
				плане, например 1.0000001 &ndash; можно быстро получить как
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10ˣ</span>
				(кто-то можета подумать, что автор даже это предусмотрел, но нет,
				это, но только это, случайно так совпало).
				Затем <span class="but_b">БП</span>&ensp;
				<span class="but">48</span>&ensp;
				<span class="but_b">С/П</span>
			</p>
		</details>

		<details id="div_demo_tricks" open>
			<summary>
				<h4>Список трюков и недокументированных особенностей в программе</h4>
			</summary>
			которые мы использовали в программе для её сокращения
			(чтобы всё влезло).
			<ul>
				<li>
					Адрес перехода храниться в регистре для сокращения длины команды при
					косвенном обращении. Для R7 это команды по адресам 05, 46, 66, и 80.
					Для R8 &ndash; команда по адресу 62.
					Для R9	&ndash; команды по адресам 32, 71, 76, 79.
				</li>
				<li>
					Использовании константы в двух смыслах. R5 &ndash; как коэффициент
					умножения по адресу 26, так и для "сдвига" во второй разряд
					по адресу 86.
					R7 &ndash; тоже как коэффициент умножения, но и как адрес перехода.
					R8 &ndash; кроме косвенной адресации используется отрицательным для
					проверки хода поиска клада по адресу 27. R9 &ndash; кроме косвенной
					адресации используется для корректировки округления по адресу 34.
				</li>
				<li>
					Цикличность адресного пространства. В процедуре после команды по адресу
					47 нет команды <span class="but_b">В/О</span>, и последняя команда в
					программе также не <span class="but_b">В/О</span>,
					которая "удачно" расположена по нулевому адресу, для этих случаев.
				</li>
				<li>
					Использование хвоста одной процедуры для другой: основная подпрограмма,
					которая вызывается из многих мест,
					идёт сразу после окончания вычисления нового положения (адрес 41).
				</li>
				<li>
					"Слияние" окончания одной процедуры с другой для исключению команды
					перехода. В данном случае окончание инициализации и начало
					взлома стены по адресу 63. А также слияние двух веток вычисления
					(этажной и межэтажной) по адресу 38.
				</li>
				<li>
					Регистр X2. Несколько раз. Сохранение по адресу 10, чтобы
					извлечь по адресу 15, уже после того, как значение поучаствовало в
					операции сложения (экономия регистра), причем с применением не
					X2-влияющей <big>&pi;</big> вместо тройки. Сохранение по адресу 27 и
					восстановление по адресу 33 (экономия одной команды). Сохранение
					по адресу 85 и нестандартное восстановление по адресу 90
					(экономия нескольких команд).
				</li>
				<li>
					Использование ВП. Совмещение восстановления X2 с неявное операцией
					взятия дробной части по адресу 15. Объединение X2 и шестнадцатеричной
					цифры по адресу 90.
				</li>
				<li>
					Использование знаний косвенной адресации. Кроме значений в регистре
					R7 &hellip; R9, это "игнорирование" дробной части после сложения по
					адресам 13 или 38, и умышленное "отрубание" её по адресу 92.
					А также необычное использование регистра R0 в цикле по адресу 62
					с отрицательным счётчиком.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">ЗН</span> как команда
					умножения на 2 по адресу 19.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&or;</span> для
					проверки, что число содержит более одной цифры по адресу 30. Тут
					следует сравнить с оригиналом, где автор для проверки выхода за
					границы верх/низ использовал конъюнкцию квадрата нового положения
					и числа <big>&pi;</big>, проверяя нулевой бит (and 1) во втором разряде 
					(после возведения в квадрат 5² = 25 и 16² = 256 его содержат, 
					а 1² = 1, 2² = 4, 4² = 16, 8² = 64 &ndash; нет).
					Вроде, это выглядит как альтернатива, вместо команд
					<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
					<span class="but">&times;</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&or;</span>
					использовать
					<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
					<span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&and;</span>, при условии,
					чтобы <big>&pi;</big> было "справа" (чтобы правильно пройти
					процедуру очистки, благодаря отрезанию первой цифры и тому,
					что биты 2 и 3 у числа <big>&pi;</big>
					не пересекаются: для 3.14&hellip; это 1 и 4).
					Это даже можно сделать, длина
					программы не измениться, даже R6 можно сделать обычным 0.1.
					Но тут есть подводный камень:
					процедура очистки также запомнит число "справа" в Rb, а для процедуры
					подрыва и проверки выхода за границу Rb такое количество цифр в числе
					недопустимо (процедура очистки вместо очистки внесёт в Ra что-то
					случайное). Вот так, иногда приходится использовать недокументированные
					возможности для корректности поведения алгоритма
					(без увеличения длины программы).
				</li>
				<li>
					Использование шестнадцатеричной арифметики. Содержимое регистра R6
					используется то как 0.1 по адресу 26, то как увеличения количества
					значащих цифр по адресу 29. Операция вычитания по адресу 95 приводит
					цифры C, D, E к более удобным 1, 2, 3.
				</li>
				<li>
					Использование <span class="but_k">К</span><span class="op_k">max</span>
					в нестандартном случае для "просвечивания" нуля из Y по адресу 45.
					Тут нужно заметить, что процедура по адресу 41 может быть реализована
					разными способами. Например и так:
					<span class="but">&lt;-&gt;</span>&ensp;
					<span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&and;</span>&ensp;
					<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
					<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span>&ensp;
					<span class="but_b">П&rarr;x</span><span class="reg">b</span>&ensp;
					<span class="but_b">x&rarr;П</span><span class="reg">a</span>.
					Но при этом в стеке останется план этажа/кладов при неудаче. А этой
					подсказки хотелось бы избежать, т.к. многие команды игры подразумевают
					дополнительную информацию в регистре Y после остановки.
					При том порядке что у нас, план этажа/кладов безвозвратно
					теряется из стека в любом случае (удача или нет).
				</li>
			</ul>
			<p>
				Как не странно, даже такую "плотную" программу можно ещё улучшить.
				Например, если потребовать в начале каждой игры 
				после ввода начального положения нажатия
				<span class="but">В&uarr;</span> перед <span class="but_b">C/П</span>. 
				Тогда начало можно переместить на адрес 44,
				где уже есть команда <span class="but_b">x&rarr;П</span><span class="reg">b</span>,
				и убрать её с адреса 48. При этом, кстати, будет реализован редкий
				трюк, связанный с исполнением одних и тех же команд, но в
				разных адресных ветках вычисления (и с разными целями и результатом).
				А потом, например, использовать
				сэкономленную команду для начального обнуления количества сокровищ, например
				<span class="but_b">x&rarr;П</span><span class="reg">с</span> по адресу 54.
			</p>
		</details>
	</details>

	<hr>

	<details id="div_command" open>
		<summary><h3>Приложение. Все команды</h3></summary>
		Список всех 256 команд ПМК с дополнительным комментарием, в случае
		наличия недокументированных возможностей.
		<p></p>
		<table>
			<tr><th>Код</th><th>Вид</th><th>Название</th><th>Комментарий</th></tr>
			<tr>
				<th>00&hellip;09</th>
				<td class="tdcenter">
					<span class="but">0</span>&hellip;<span class="but">9</span>
				</td>
				<td>Ввод числа</td>
				<td>
					Ввод цифр идёт даже через границу
					<span class="but_b">С/П</span>. Т.е. если в начале программы
					идёт цифра(ы), а перед её запуском тоже ввод, то он продолжиться.
					То же касается и разделителя <span class="but">.</span>, он может
					как заканчивать ввод в режиме вычислений, так и начинать в
					программе &ndash; будет воспринят как разделитель целой и дробной
					части.
					<br>
					Второе нажатие <span class="but">.</span> для разделения разрядов
					игнорируется.
					<br>
					Если предыдущая команда была не ввод цифры или разделителя, а так
					же не команда <span class="but">В&uarr;</span>, то предварительно
					осуществляется сдвиг стека под новое число.
				</td>
			</tr>
			<tr>
				<th>0A</th>
				<td class="tdcenter"><span class="but">.</span></td>
				<td>Разделитель целой и дробной части</td>
				<td>
					Кроме того, что указано выше восстановление X2&rarr;X. См.
					<a href="#div_x2_point">Таинственный регистр X2</a>.
				</td>
			</tr>
			<tr>
				<th>0B</th>
				<td class="tdcenter"><span class="but">/-/</span></td>
				<td>Смена знака</td>
				<td>
					Предыдущее значение НЕ копируется в X1.
					Cм. также <a href="#div_x2_sum">Таинственный регистр X2</a>.
				</td>
			</tr>
			<tr>
				<th>0C</th>
				<td class="tdcenter"><span class="but">ВП</span></td>
				<td>Ввод порядка</td>
				<td>
					Если X = 0, то он заменяется на 1. Для многих чисел ввод порядка означает
					умножение на 10 в соответствующей степени.
					<br>
					После ввода порядка можно ещё раз нажать <span class="but">ВП</span> и
					ввести число &ndash; в этом случае порядки складываются.
					<br>
					Знак порядка можно ввести как сразу после <span class="but">ВП</span>,
					так и после ввода цифр.
					<br>
					Также см. <a href="#div_x2_exp">Таинственный регистр X2</a>.
				</td>
			</tr>
			<tr>
				<th>0D</th>
				<td class="tdcenter"><span class="but_cx">Сx</span></td>
				<td>Сброс X в ноль</td>
				<td>Важное свойство &ndash; стек не двигается.</td>
			</tr>
			<tr>
				<th>0E</th>
				<td class="tdcenter"><span class="but">В&uarr;</span></td>
				<td>Сдвиг стека</td>
				<td>
					Если последующая команда &ndash; ввод числа, то будет ввод в X, если
					извлечение из памяти или F<big>&pi;</big> &ndash;
					то стек ещё раз сдвинется.
				</td>
			</tr>
			<tr>
				<th>0F</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td>Полный сдвиг, включая X1</td>
				<td>
					Единственная документированная и вводимая команда с цифрой F в коде.
				</td>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td class="tdcenter"><span class="but">+</span></td>
				<td>Сложение</td>
				<td>
					Результат проверяется только при X&rarr;X2, т.е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>11</th>
				<td class="tdcenter"><span class="but">-</span></td>
				<td>Вычитание</td>
				<td>
					Результат проверяется только при X&rarr;X2, т.е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>12</th>
				<td class="tdcenter"><span class="but">&times;</span></td>
				<td>Умножение</td>
				<td>
					Результат проверяется при X&rarr;X2, т.е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>13</th>
				<td class="tdcenter"><span class="but">&divide;</span></td>
				<td>Деление</td>
				<td>
					Ошибка деления на ноль возникает безусловно, остальное при
					X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>14</th>
				<td class="tdcenter"><span class="but">&lt;-&gt;</span></td>
				<td>Обмен X и Y</td>
				<td></td>
			</tr>
			<tr>
				<th>15</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">10ˣ</span>
				</td>
				<td>Возведение в степень числа 10</td>
				<td>
					Аргументы на переполнение порядка (сверхчисло) проверяется
					безусловно, а не при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>16</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">eˣ</span>
				</td>
				<td>Возведение в степень числа e (экспонента)</td>
				<td>
					Аргументы на переполнение порядка (сверхчисло) проверяется
					безусловно, а не при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>17</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">lg</span></td>
				<td>Десятичный логарифм</td>
				<td>
					Аргументы (должно быть больше нуля) проверяется безусловно, а не
					при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>18</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">ln</span></td>
				<td>Натуральный (экспоненциальный) логарифм</td>
				<td>
					Аргументы (должно быть больше нуля) проверяется безусловно, а не
					при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>19</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">sin⁻¹</span>
				</td>
				<td>Арксинус</td>
				<td>
					Аргументы (должно |X|&les;1) проверяется безусловно, а не при
					X&rarr;X2. Для ГРД/Г и X = 0 выводит X = 00.
				</td>
			</tr>
			<tr>
				<th>1A</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">cos⁻¹</span>
				</td>
				<td>Арккосинус</td>
				<td>
					Аргументы (должно |X|&les;1) проверяется безусловно, а не при
					X&rarr;X2. arccos(1) для ГРД/Г даёт не нормализованное 00.
				</td>
			</tr>
			<tr>
				<th>1B</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">tg⁻¹</span>
				</td>
				<td>Арктангенс</td>
				<td></td>
			</tr>
			<tr>
				<th>1C</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">sin</span></td>
				<td>Синус</td>
				<td></td>
			</tr>
			<tr>
				<th>1D</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">cos</span></td>
				<td>Косинус</td>
				<td></td>
			</tr>
			<tr>
				<th>1E</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">tg</span></td>
				<td>Тангенс</td>
				<td>
					Аргументы проверяется безусловно, а не при X&rarr;X2.
					При X = <big>&pi;</big>/2 + n &times; <big>&pi;</big> будет ошибка.
				</td>
			</tr>
			<tr>
				<th>1F</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td>Число <big>&pi;</big> (пи)</td>
				<td>
					Кроме того, что сдвигает стек (это документировано), также копирует
					предыдущее X в X1, как арифметическая операция (а это нет).
				</td>
			</tr>
			<tr>
				<th>21</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">&radic;</span>
				</td>
				<td>Квадратный корень</td>
				<td>Аргументы проверяется безусловно (X&ges;0), а не при X&rarr;X2.</td>
			</tr>
			<tr>
				<th>21</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">x&sup2;</span>
				</td>
				<td>Возведение в квадрат</td>
				<td>
					Результат проверяется при X&rarr;X2, т.е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>23</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">1/x</span></td>
				<td>Обратная величина</td>
				<td>
					Ошибка деления на ноль возникает безусловно, остальное -
					при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>24</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">xʸ</span>
				</td>
				<td>Возведение в степень.</td>
				<td>
					Ошибка, если X = 0. Не принимает отрицательный X, даже когда это
					математически допустимо.
					<br>
					Ошибка переполнения возникает безусловно, а не при X&rarr;X2.
					<br>
					Стек не сокращается, в отличие от обычных арифметических операций.
					Т.е. число в Y остается на месте (позволяя ещё раз возвести в ту
					же степень).
				</td>
			</tr>
			<tr>
				<th>25</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">&orarr;</span>
				</td>
				<td>Подтягивание стека</td>
				<td></td>
			</tr>
			<tr>
				<th>26</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>
				</td>
				<td>
					Перевод угловых или временных величин из обычной формы в часть целой
				</td>
				<td>
					Если дробное значение &ges;0.6, то будет ошибка.
					Целая часть не меняется, даже если шестнадцатеричное число.
				</td>
			</tr>
			<tr>
				<th>27</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="but">&minus;</span>
				</td>
				<td>Ошибка</td>
				<td>ЕГГ0Г.</td>
			</tr>
			<tr>
				<th>28</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="but">&times;</span>
				</td>
				<td>Ошибка</td>
				<td>ЕГГ0Г.</td>
			</tr>
			<tr>
				<th>29</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="but">&divide;</span></td>
				<td>Ошибка</td>
				<td>ЕГГ0Г.</td>
			</tr>
			<tr>
				<th>2A</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
				</td>
				<td>
					Перевод угловых или временных величин из обычной формы в часть
					целой, включая секунды
				</td>
				<td>
					Если дробное значение &ges;0.6, то будет ошибка.
					Целая часть не меняется, даже если шестнадцатеричное число.
				</td>
			</tr>
			<tr>
				<th>2B&hellip;2E</th>
				<td></td>
				<td>Ошибка</td>
				<td>ЕГГ0Г.</td>
			</tr>
			<tr>
				<th>2F</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>&#8202;30&#8202;|&#8202;</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
				</td>
				<td>
					Перевод угловых или временных величин из части целого в обычную
					форму, включая секунды
				</td>
				<td>
					Если дробная часть &les; 2^.-07, то обратное преобразование
					уже не срабатывает. Если = 1^.-07 то уже и прямое преобразование
					не меняет значение. Если целая часть шестнадцатеричное число и нет
					дробной части или оно = 1^.-07 &ndash; оно
					<a href="#div_glos_normalization">нормализуется</a>, как в
					операциях с шестнадцатеричными цифрами. Иначе остается без изменений.
				</td>
			</tr>
			<tr>
				<th>31</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&mid;x&mid;</span>
				</td>
				<td>Модуль</td>
				<td></td>
			</tr>
			<tr>
				<th>32</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">ЗН</span></td>
				<td>Знак числа</td>
				<td>Отрицательный ноль преобразуется в ноль.</td>
			</tr>
			<tr>
				<th>33</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>
				</td>
				<td>
					Перевод угловых или временных величин из части целого в обычную
					форму
				</td>
				<td>
					Если дробная часть &les; 2^.-07, то обратное преобразование
					уже не срабатывает. Если = 1^.-07 то уже и прямое преобразование
					не меняет значение. Если целая часть шестнадцатеричное число и нет
					дробной части или оно = 1^.-07 &ndash; оно
					<a href="#div_glos_normalization">нормализуется</a>, как в
					операциях с шестнадцатеричными цифрами. Иначе остается без изменений.
				</td>
			</tr>
			<tr>
				<th>34</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td>Целая часть</td>
				<td>
					Простое отбрасывание дробной части, а не математическое нахождение
					целой части, т.е. [-1.2] = -1, а не -2.
					<br>
					Если число целое и шестнадцатеричное &ndash; оно преобразуется, как в
					операциях с шестнадцатеричными цифрами. Если есть дробная часть, то
					целая шестнадцатеричная часть остается без изменений.
				</td>
			</tr>
			<tr>
				<th>35</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td>Дробная часть</td>
				<td>
					Простое отбрасывание целой части, а не математическое нахождение
					целой части, т.е. {-1.2} = -0.2, а не 0.8.
					<br>
					Для целых чисел по модулю &lt; 10<sup>7</sup> (точнее числа, которым
					нужно меньше восьми знакомест) получается отрицательный
					ноль (в сравнениях идёт как отрицательное число и как ноль). Т.е.
					{-1234567} = -0, но {-12345678} = 0.
					<br>
					Шестнадцатеричные цифры (в дробной части) сохраняются.
				</td>
			</tr>
			<tr>
				<th>36</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">max</span></td>
				<td>Максимум</td>
				<td>
					Ноль исключение &ndash; самое большое число.
					<br>
					Обмена X и Y не происходит, т.е. либо X и Y после операции
					совпадают (в Y был максимум), либо остаются как есть
					(кроме копирования X в X1).
				</td>
			</tr>
			<tr>
				<th>37</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&and;</span>
				</td>
				<td>Логическое умножение (AND)</td>
				<td rowspan="4">
					В логических операциях первая цифра заменяется на 8, а над
					остальными цифрами мантиссы проводится побитовая операция, как с
					шестнадцатеричными числами.  Порядок и знак исходных чисел
					значения не имеют, они могут быть даже пустышкой.
					Результат всегда в форме 8.HHHHHHH
					<br>
					Стек для двухоперандных операций не сокращается, что позволяет
					выполнить операцию ещё раз.
				</td>
			</tr>
			<tr>
				<th>38</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td>Логическое сложение (OR)</td>
			</tr>
			<tr>
				<th>39</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_k">&oplus;</span>
				</td>
				<td>Логическое исключающее или (XOR)</td>
			</tr>
			<tr>
				<th>3A</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
				<td>Логическая инверсия (NOT)</td>
			</tr>
			<tr>
				<th>3B</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				<td>Случайное число</td>
				<td>
					Единица не бывает. Ноль бывает в редких случаях (когда в Y
					шестнадцатеричное число, то последовательность может выдавать и ноль).
					Датчик не очень хороший, часто циклиться (от применения команд с К).
					<br>
					Сбросить на начало (как при включении) можно с помощью операции
					<span class="but_k">К</span><span class="op_k">max</span>,
					когда регистр Y нулевой.
				</td>
			</tr>
			<tr>
				<th>3C</th>
				<td></td>
				<td>Ошибка</td>
				<td>ЕГГ0Г.</td>
			</tr>
			<tr>
				<th>3D</th>
				<td></td>
				<td>
					То же, что и команда
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					(код 2A)
				</td>
				<td></td>
			</tr>
			<tr>
				<th>3E</th>
				<td></td>
				<td>Копирование Y в X (а X&rarr;X1)</td>
				<td>
					Те же действия, что и пара команд
					<span class="but_f">F</span><span class="op_f">&orarr;</span>&ensp;
					<span class="but">В&uarr;</span>, только не X2-влияющая.
				</td>
			</tr>
			<tr>
				<th>3F</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>40&hellip;4E</th>
				<td class="tdcenter">
					<span class="but_b">x&rarr;П</span><span class="but">R</span>
				</td>
				<td>Сохранение X в регистр R0&hellip;Re</td>
				<td></td>
			</tr>
			<tr>
				<th>4F</th>
				<td class="tdcenter"></td>
				<td>Сохранение X в регистр R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>&#8202;50&#8202;|&#8202;</th>
				<td class="tdcenter"><span class="but_b">С/П</span></td>
				<td>Стоп/пуск</td>
				<td></td>
			</tr>
			<tr>
				<th>51</th>
				<td class="tdcenter"><span class="but_b">БП</span></td>
				<td>Безусловный переход</td>
				<td></td>
			</tr>
			<tr>
				<th>52</th>
				<td class="tdcenter"><span class="but_b">В/О</span></td>
				<td>Возврат обратно</td>
				<td>
					Стек обратных адресов подпрограмм из 5 ячеек, вначале нулевых.
					При возврате из подпрограммы берётся значение верхней ячейки
					стека + 1 (для определения точки возврата) и стек сдвигается,
					поэтому сразу после включения ПМК команда
					<span class="but_b">В/О</span> эквивалентна
					<span class="but_b">БП</span><span class="but">01</span>.
					Но если стек адресов возврата заполнился до конца, то последний
					адрес стека начинает копироваться и <span class="but_b">В/О</span>
					будет на этот адрес + 1.  Для зануления стека, в этом случае,
					можно воспользоваться знаниями Еггогологии и вызвать нулевого 3Г0ГГа:
					<p>
						<span class="but_cx">Cx</span>&ensp;
						<span class="but">В&uarr;</span>&ensp;
						<span class="but">&divide;</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x&sup2;</span>&ensp;
						<span class="but_cx">Cx</span>&ensp;
						<span class="but">&lt;-&gt;</span>&ensp;
						<span class="but_cx">Cx</span>
					</p>
					Или запустить ненадолго бесконечную программу из одного
					оператора, например
					<span class="code_num">00.</span><span class="but_k">K</span><span class="but_b">ПП</span><span class="but">9</span>,
					при условии, что R9 = 0.
				</td>
			</tr>
			<tr>
				<th>53</th>
				<td class="tdcenter"><span class="but_b">ПП</span></td>
				<td>Вызов подпрограммы</td>
				<td>
					Переход на адрес подпрограммы, указанный следующей командой. Этот
					адрес запоминается в стеке обратных адресов
					(см. <span class="but_b">В/О</span>).
				</td>
			</tr>
			<tr>
				<th>54</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td>Пустой оператор</td>
				<td></td>
			</tr>
			<tr>
				<th>55</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="but">1</span></td>
				<td>Пустой оператор</td>
				<td></td>
			</tr>
			<tr>
				<th>56</th>
				<td class="tdcenter"><span class="but_k">К</span><span class="but">2</span></td>
				<td>Пустой оператор</td>
				<td></td>
			</tr>
			<tr>
				<th>57</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">x&ne;0</span>
				</td>
				<td>Если не ноль</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X не равно нулю (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>58</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">L2</span></td>
				<td>Цикл по регистру R2</td>
				<td></td>
			</tr>
			<tr>
				<th>59</th>
				<td class="tdcenter"
					><span class="but_f">F</span><span class="op_f">x&ge;0</span>
				</td>
				<td>Если больше или равно нулю</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X больше или равно нулю (в большинстве языков обычно наоборот,
					переход на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>5A</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">L3</span></td>
				<td>Цикл по регистру R3</td>
				<td></td>
			</tr>
			<tr>
				<th>5B</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">L1</span></td>
				<td>Цикл по регистру R1</td>
				<td></td>
			</tr>
			<tr>
				<th>5C</th>
				<td class="tdcenter">
					<span class="but_f">F</span><span class="op_f">x&lt;0</span>
				</td>
				<td>Если меньше нуля</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X меньше нуля (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>5D</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">L0</span></td>
				<td>Цикл по регистру R0</td>
				<td></td>
			</tr>
			<tr>
				<th>5E</th>
				<td class="tdcenter"><span class="but_f">F</span><span class="op_f">x=0</span></td>
				<td>Если равно нулю</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X равно нулю (в большинстве языков обычно наоборот, переход на
					адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>5F</th>
				<td class="tdcenter"></td>
				<td>Зависание</td>
				<td>
					Визуально воспринимается как зависание. ПМК не реагирует на ввод
					команд и ничего не отображает.
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>60&hellip;6E</th>
				<td class="tdcenter">
					<span class="but_b">П&rarr;x</span><span class="but">R</span>
				</td>
				<td>Извлечение из регистра R0&hellip;Re в X</td>
				<td></td>
			</tr>
			<tr>
				<th>6F</th>
				<td class="tdcenter"></td>
				<td>Извлечение из регистра R0 в X</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>70&hellip;7E</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход при неравенстве нулю, адрес перехода в
					регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X не равно нулю (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>7F</th>
				<td></td>
				<td>
					Косвенный условный переход при неравенстве нулю, адрес перехода в
					регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X не равно нулю (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>80&hellip;8E</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
				</td>
				<td>
					Косвенный безусловный переход на адрес перехода в регистре
					R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>8F</th>
				<td></td>
				<td>Косвенный безусловный переход на адрес перехода в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>90&hellip;9E</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход если больше или равно нулю, адрес
					перехода в регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X больше или равно нулю (в большинстве языков обычно наоборот,
					переход на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>9F</th>
				<td></td>
				<td>
					Косвенный условный переход если больше или равно нулю, адрес
					перехода в регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X больше или равно нулю (в большинстве языков обычно наоборот,
					переход на адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>A0&hellip;AE</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="but_b">ПП</span><span class="but">R</span>
				</td>
				<td>
					Косвенный вызов подпрограммы по адресу в регистре R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>AF</th>
				<td></td>
				<td>Косвенный вызов подпрограммы по адресу в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>B0&hellip;BE</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>
				</td>
				<td>
					Косвенное сохранение X в регистр, по номеру в регистре
					R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>BF</th>
				<td></td>
				<td>Косвенное сохранение X в регистр, по номеру в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>C0&hellip;CE</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход если меньше нуля, адрес перехода в
					регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X меньше нуля (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>CF</th>
				<td></td>
				<td>
					Косвенный условный переход если меньше нуля, адрес перехода в
					регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X меньше нуля (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>D0&hellip;DE</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
				</td>
				<td>
					Косвенное извлечение X из регистра, по номеру в регистре
					R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>DF</th>
				<td></td>
				<td>Косвенное извлечение X из регистра, по номеру в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>E0&hellip;EE</th>
				<td class="tdcenter">
					<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход если равно нулю, адрес перехода в
					регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X равно нулю (в большинстве языков обычно наоборот, переход на
					адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>EF</th>
				<td></td>
				<td>
					Косвенный условный переход если равно нулю, адрес перехода в
					регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X равно нулю (в большинстве языков обычно наоборот, переход на
					адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>F0&hellip;FF</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
		</table>
		<p>
			Некоторые команды с цифрой F в коде можно получить тоже
			недокументированным образом.
		</p>
		<p>
			Команды F0&hellip;FE получаются по адресам 30&hellip;44 после выполнения
			в режиме вычислений пары команд
			<span class="but_b">В/О</span>&ensp;
			<span class="but_k">К</span><span class="but_b">ПП</span><span class="but">R</span>
			(R = 0&hellip;e), которые переведут ПМК в режим ввода программы и вставят
			код с цифрой F. При этом в регистрах R0&hellip;R3 должно быть число
			заканчивающееся на 1 или 2 (точнее такое, чтобы после косвенной адресации
			заканчивалось на 1 или 2). Если там будет другое (например, ноль, как
			после включения ПМК), то для R1&hellip;R3 вставится F0&hellip;F2 по
			адресу 30&hellip;32, а для R0 это будет самый быстрый способ получить
			3Г0ГГа (причем перехода в режим ввода программы не произойдёт).
		</p>
		<p>
			Последовательность 5 команд FF (через одну) можно получить
			по любому адресу, если стек возврата "забить" числом, начинающимся
			с пустышки, и перед переходом в режим ПРГ нажимается
			<span class="but">БП</span> "Адрес". Тогда
			начиная с адреса "Адрес"-11 через одну будут проставлены команды FF.
			<br>
			Для начала получим адрес с начальной пустышкой, например число F8, и
			сохраним в регистр, например в R7. Не забыть при этом в конце убрать
			такое число с начальной пустышкой из RX!
			<br>
			<span class="but">8</span>&ensp;
			<span class="but">8</span>&ensp;
			<span class="but">8</span>&ensp;
			<span class="but">В&uarr;</span>&ensp;
			<span class="but">7</span>&ensp;
			<span class="but">7</span>&ensp;
			<span class="but_k">K</span><span class="op_k">&or;</span>&ensp;
			<span class="but_k">K</span><span class="op_k">{x}</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but">2</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
			<span class="but_cx">Cx</span>
			<br>
			Теперь по этому "темному" адресу вставим команду вызова подпрограммы
			по R7:
			<br>
			<span class="but_k">K</span><span class="but_b">БП</span><span class="but">7</span>&ensp;
			<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
			<span class="but_k">K</span><span class="but_b">ПП</span><span class="but">7</span>&ensp;
			<span class="but_f">F</span><span class="op_f">АВТ</span>&ensp;
			<span class="but_k">K</span><span class="but_b">БП</span><span class="but">7</span>
			<br>
			Потом 5 раз (чтобы забить стек возврата) нажмем <span class="but_b">ПП</span>
			<br>
			После этого уже выбираем, где нам нужны команды FF. Пусть мы хотим их с
			адреса 80. Тогда делаем переход на 80+11=91
			<span class="but_b">БП</span><span class="but">91</span> и
			<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
			<span class="but_f">F</span><span class="op_f">АВТ</span>
			<br>
			Теперь по адресам 80, 82, 84, 86, 88 добавилась команда FF. Если нужно
			побольше, например ещё и по адресам 81, 83, 85, 87, 89, то просто снова
			заполним стек возврата
			<span class="but_k">K</span><span class="but_b">БП</span><span class="but">7</span>,
			5 раз <span class="but_b">ПП</span>, и после
			<span class="but_b">БП</span><span class="but">92</span> и
			<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
			<span class="but_f">F</span><span class="op_f">АВТ</span>
			получим то, что хотели.
			<br>
			Не забудьте в конце почистить стек возврата (как указано в примечание для
			команды В/О)!
		</p>
	</details>

	<hr>

	<details id="div_glossary" open>
		<summary><h3>Список терминов</h3></summary>
		<dl>
			<dt>ЕГГ0Г</dt>
			<dd>
				<div id="div_glos_err100">
					В общем случае отображение об ошибке операции, в
					частности числа в диапазоне 1<sup>100</sup>&hellip;1<sup>199</sup>.
				</div>
			</dd>
			<dt>3Г0ГГ</dt>
			<dd>
				<div id="div_glos_err200">
					Числа в диапазоне 1<sup>200</sup>&hellip;1<sup>299</sup>.
				</div>
			</dd>
			<dt>Еггогология</dt>
			<dd>
					<div id="div_glos_errors">
						Изучение недокументированных возможностей ПМК,
						главным образом в области сверхчисел. См.
						<a href="https://ru.wikipedia.org/wiki/Еггогология" target="_blank">
							https://ru.wikipedia.org/wiki/Еггогология
						</a>
					</div>
				</dd>
				<dt>Знакоцифра</dt>
			<dd>
				<div id="div_glos_zero_digit">
					Цифра, которая располагается на месте знака. См.
					<a href="#div_zero_digit">
						Числа, у которых вместо знака стоит цифра.
					</a>
				</div>
			</dd>
			<dt>Не нормализованные числа</dt>
			<dd>
				<div id="div_glos_unnormalize">
					Числа, у которых отображаются ведущие нули.
				</div>
			</dd>
			<dt>Нормализация</dt>
			<dd>
				<div id="div_glos_normalization">
					Нормализация &ndash; вывод числа без ведущих нулей. Также в контексте
					преобразования числа с шестнадцатеричными цифрами означает
					преобразование в число с десятичными числами, с переносом лишней
					десятки в старший разряд.
				</div>
			</dd>
			<dt>ПМК</dt>
			<dd>
				<div id="div_glos_calculator">
					Программируемый микрокалькулятор.
					В контексте статьи &ndash; МК-61.
				</div>
			</dd>
			<dt>Пустышка</dt>
			<dd>
				<div id="div_glos_F">
					Число, у которого первая цифра представлена
					шестнадцатеричной цифрой F. Такие цифры не отображаются ПМК, т.е.
					выглядят как пустое знакоместо.
				</div>
			</dd>
			<dt>Регистр X2</dt>
			<dd>
				Или экранный регистр &ndash; см.
				<a href="#div_x2">Таинственный регистр X2</a>.
			</dd>
			<dt>Сверхчисло</dt>
			<dd>
				<div id="div_glos_super_num">
					Число, порядок которого превышает документированный
					диапазон чисел для ПМК, т.е. порядок не в диапазоне -99&hellip;99,
					например 1<sup>120</sup>, или 4<sup>-180</sup>.
				</div>
			</dd>
			<dt>Темные адреса</dt>
			<dd>
				<div id="div_glos_shadow">
					Шестнадцатеричные адреса, располагаясь на которых
					в режиме ввода программы ПМК не отображает коды операций (тёмный экран).
				</div>
			</dd>
		</dl>
	</details>

	<footer>
		<address class="align_right">Автор документа: Анваров С.Р.</address>
	</footer>

</body>
</html>
